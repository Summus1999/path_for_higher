# C++新八股文

## 面向对象基础

#### C++面向对象的三大特性

**封装**：隐藏实现细节，实现模块化。控制访问权限，private仅对自己和友元开放，protected开放给子类，public开放给所有对象。

**继承**：无需修改原有类的情况下实现对功能的扩展。存在三种继承，即private继承，protected继承和public继承，解决基类在子类中最高权限的问题(即基类中是public，子类中为private，则权限在子类中修改为private级别，也可以使用using去修改权限)，还可以做多继承和接口继承。

**多态**：一个接口多种形态，通过实现接口重用增加可扩展性。分为静态多态和动态多态。

- 静态多态：发生在编译期,主要包括函数重载和模板。
- 动态多态：发生在运行期,通过虚函数实现。基类中将成员函数声明为 `virtual`, 派生类重写该函数, 并通过基类指针或引用调用, 这样在运行时会根据对象的实际类型选择调用哪个版本。

#### C++多态的实现

C++ 多态分为静态多态和动态多态。

**静态多态**发生在编译期,主要包括函数重载和模板。  

- 函数重载: 同一作用域下,函数名相同,参数列表不同,编译器在编译期根据实参类型/数量选择合适的重载版本。  
- 函数模板: 使用类型参数编写一份通用代码,编译器在编译期根据实参类型对模板进行实例化,生成不同的函数实现。

**动态多态**发生在运行期,通过虚函数实现。基类中将成员函数声明为 `virtual`, 派生类重写该函数, 并通过基类指针或引用调用, 这样在运行时会根据对象的实际类型选择调用哪个版本。

其本质是**晚绑定**:  

- 非虚函数在编译期就确定调用地址(早绑定);  
- 虚函数通过虚函数表(vtable)实现, 对象中有一个虚表指针(vptr), 在构造时初始化, 运行时通过 vptr 在虚表中查找实际要调用的函数地址。

####  C++ 的构造函数能否定义为虚函数？

不能,语法上就不允许给构造函数加 `virtual`。

原因:

- 虚函数依赖虚函数表 (vtable) 和虚表指针 (vptr) 实现运行时多态。vptr 是在对象构造过程中由构造函数负责初始化的,也就是说,***\*对象还没完全构造好之前,就谈“根据动态类型做虚派发”在语义上说不通\****。

- 构造顺序是自上而下: 先调用基类构造函数,再依次调用派生类构造函数。在执行基类构造函数时,对象只能被当作“基类子对象”来看待,此时即使有虚派发,也只会调用基类版本,达不到“根据派生类型选择构造函数”的效果。

因此 C++ 标准直接禁止“虚构造函数”。如果需要“多态创建对象”,通常通过**工厂函数/虚 clone 接口\**等模式来实现。

#### 虚函数和纯虚函数的区别？

- 虚函数: 用 `virtual` 声明，可有默认实现，派生类可选重写，类可实例化。运行时通过基类指针/引用动态绑定到实际类型的函数。

- 纯虚函数: 声明后加 `=0`，无默认实现，强制派生类重写。包含纯虚函数的类是抽象类，不可实例化，用于定义接口规范。

#### 虚析构函数的作用？

**核心作用**: 确保通过基类指针删除派生类对象时，能正确调用派生类析构函数，避免资源泄漏。

原理: 非虚析构时，`delete` 基类指针只调用基类析构函数 → 派生类资源无法释放。虚析构通过动态绑定，保证先调用派生类析构，再调用基类析构。

**适用场景**:

-  多态基类（通过基类指针管理派生类对象）

-  抽象接口类

-  派生类含动态资源

#### 继承下的构造函数和析构函数执行顺序？

**构造顺序**（从上到下）:

1. 基类构造函数
2. 派生类成员对象构造函数（按声明顺序）
3. 派生类自身构造函数

**析构顺序**（与构造相反）:

1. 派生类自身析构函数
2. 派生类成员对象析构函数（按声明逆序）
3. 基类析构函数

**原理**: 确保派生类使用基类资源前，基类已完成初始化；销毁时先释放派生类资源，再释放基类资源。

多继承情况: 按继承列表顺序依次构造基类，析构时逆序。

#### 虚函数表和虚指针的创建时机？

- **虚函数表**: 编译期生成。编译器检测到 `virtual` 关键字时为类生成虚表（函数指针数组）。派生类重写虚函数时更新表中地址。

- ***虚指针**: 运行期对象构造时初始化。每个对象独立拥有 vptr，位于对象内存布局起始位置，指向所属类的虚表。

## 内存管理

## 关键字与语法

#### C++ 指针和引用的区别？

**引用的本质**：引用是对象的别名,从语义上看“不是一个独立对象”。  
在大多数实现中,编译器会用一个隐藏指针来实现引用,因此它通常占用与指针相同的空间,但这属于实现细节,标准并不强制,一般不在代码中依赖 `sizeof(引用)` 的具体值。

指针与引用的区别:

- 指针本身是一个对象,有自己的地址,可以赋值、拷贝,也可以指向不同的对象,还能为 `nullptr`。
- 引用在定义时**必须初始化**,并且一旦绑定某个对象后就不能再改为引用其他对象,通常也不允许“空引用”。
- 使用指针需要显式解引用 `*p` 访问目标对象;引用则可以像普通变量一样直接使用。
- 语义上,指针适合表示“可选/可变的指向关系”(可以为空、可以重指向),引用适合表示“必须存在的别名”,常用于函数参数和返回值以避免拷贝。

#### override和final关键字的作用？



## modern C++特性

### C++11

#### 智能指针有没有了解? 三种智能指针讲一下

智能指针是基于 RAII 封装裸指针的类对象,在构造时获取资源,在析构时自动释放资源,避免忘记 delete、异常路径泄露等问题。

- `shared_ptr` : 共享所有权,内部维护引用计数。每次拷贝计数 +1,销毁或 reset 计数 -1,为 0 时自动释放对象。计数本身是线程安全的,但多线程同时读写同一对象仍需加锁。

- `unique_ptr` : 独占所有权,禁止拷贝,只支持移动。同一时间只能有一个 `unique_ptr` 指向该对象,适合唯一拥有者场景,开销最小。

- `weak_ptr` : 不参与所有权,从 `shared_ptr` 构造,只做“旁观者”。不会增加引用计数,常用于解决 `shared_ptr` 之间的循环引用,需要访问时通过 `lock()` 临时升级为 `shared_ptr`。

Tips: `auto_ptr` 已在 C++11 中废弃, C++17 中移除。

### C++14

### C++17

## 模板与泛化

## STL容器

## 多线程与并发

#### 对锁有没有了解,介绍一下？

常见 C++ 锁类型:

- `std::mutex`               : 最基本的互斥锁,不可重入。
- `std::recursive_mutex`     : 可重入互斥锁,同一线程可多次加锁。
- `std::timed_mutex`         : 带超时的互斥锁,支持 `try_lock_for/try_lock_until`。
- `std::recursive_timed_mutex`: 可重入 + 支持超时。
- `std::shared_mutex`        : 读写锁,支持多读单写,适合读多写少场景。
- `std::shared_timed_mutex`  : 在 `shared_mutex` 基础上增加超时功能。

## 编译与链接
