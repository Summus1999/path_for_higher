# C++新八股文

## 面向对象基础

#### C++面向对象的三大特性

**封装**：隐藏实现细节，实现模块化。控制访问权限，private仅对自己和友元开放，protected开放给子类，public开放给所有对象。

**继承**：无需修改原有类的情况下实现对功能的扩展。存在三种继承，即private继承，protected继承和public继承，解决基类在子类中最高权限的问题(即基类中是public，子类中为private，则权限在子类中修改为private级别，也可以使用using去修改权限)，还可以做多继承和接口继承。

**多态**：一个接口多种形态，通过实现接口重用增加可扩展性。分为静态多态和动态多态。

- 静态多态：发生在编译期,主要包括函数重载和模板。
- 动态多态：发生在运行期,通过虚函数实现。基类中将成员函数声明为 `virtual`, 派生类重写该函数, 并通过基类指针或引用调用, 这样在运行时会根据对象的实际类型选择调用哪个版本。

#### C++多态的实现

C++ 多态分为静态多态和动态多态。

**静态多态**发生在编译期,主要包括函数重载和模板。  

- 函数重载: 同一作用域下,函数名相同,参数列表不同,编译器在编译期根据实参类型/数量选择合适的重载版本。  
- 函数模板: 使用类型参数编写一份通用代码,编译器在编译期根据实参类型对模板进行实例化,生成不同的函数实现。

**动态多态**发生在运行期,通过虚函数实现。基类中将成员函数声明为 `virtual`, 派生类重写该函数, 并通过基类指针或引用调用, 这样在运行时会根据对象的实际类型选择调用哪个版本。

其本质是**晚绑定**:  

- 非虚函数在编译期就确定调用地址(早绑定);  
- 虚函数通过虚函数表(vtable)实现, 对象中有一个虚表指针(vptr), 在构造时初始化, 运行时通过 vptr 在虚表中查找实际要调用的函数地址。

####  C++ 的构造函数能否定义为虚函数？

不能,语法上就不允许给构造函数加 `virtual`。

原因:

- 虚函数依赖虚函数表 (vtable) 和虚表指针 (vptr) 实现运行时多态。vptr 是在对象构造过程中由构造函数负责初始化的,也就是说,***\*对象还没完全构造好之前,就谈“根据动态类型做虚派发”在语义上说不通\****。

- 构造顺序是自上而下: 先调用基类构造函数,再依次调用派生类构造函数。在执行基类构造函数时,对象只能被当作“基类子对象”来看待,此时即使有虚派发,也只会调用基类版本,达不到“根据派生类型选择构造函数”的效果。

因此 C++ 标准直接禁止“虚构造函数”。如果需要“多态创建对象”,通常通过**工厂函数/虚 clone 接口\**等模式来实现。

#### 虚函数和纯虚函数的区别？

- 虚函数: 用 `virtual` 声明，可有默认实现，派生类可选重写，类可实例化。运行时通过基类指针/引用动态绑定到实际类型的函数。

- 纯虚函数: 声明后加 `=0`，无默认实现，强制派生类重写。包含纯虚函数的类是抽象类，不可实例化，用于定义接口规范。

#### 虚析构函数的作用？

**核心作用**: 确保通过基类指针删除派生类对象时，能正确调用派生类析构函数，避免资源泄漏。

原理: 非虚析构时，`delete` 基类指针只调用基类析构函数 → 派生类资源无法释放。虚析构通过动态绑定，保证先调用派生类析构，再调用基类析构。

**适用场景**:

-  多态基类（通过基类指针管理派生类对象）

-  抽象接口类

-  派生类含动态资源

#### 继承下的构造函数和析构函数执行顺序？

**构造顺序**（从上到下）:

1. 基类构造函数
2. 派生类成员对象构造函数（按声明顺序）
3. 派生类自身构造函数

**析构顺序**（与构造相反）:

1. 派生类自身析构函数
2. 派生类成员对象析构函数（按声明逆序）
3. 基类析构函数

**原理**: 确保派生类使用基类资源前，基类已完成初始化；销毁时先释放派生类资源，再释放基类资源。

多继承情况: 按继承列表顺序依次构造基类，析构时逆序。

#### 虚函数表和虚指针的创建时机？

- **虚函数表**: 编译期生成。编译器检测到 `virtual` 关键字时为类生成虚表（函数指针数组）。派生类重写虚函数时更新表中地址。

- **虚指针**: 运行期对象构造时初始化。每个对象独立拥有 vptr，位于对象内存布局起始位置，指向所属类的虚表。

## 内存管理

#### 讲一下循环引用如何发生的，以及如何解决？

对象相互引用时（如双向链表、图结构），会导致引用计数无法归零，资源无法释放。使用weak_ptr打破循环引用，因为它不增加引用计数。

#### shared_ptr是线程安全的吗？多线程中使用智能指针要注意什么？

- 多线程代码操作的是同一个shared_ptr对象是**线程危险**的。

- 多线程代码操作的不是同一个shared_ptr对象，但不同的shared_ptr指向了相同的内存，此时是线程安全的。

#### 何时用shared_ptr，何时用weak_ptr?

**shared_ptr**：需要共享资源所有权时使用。

**weak_ptr**：作为shared_ptr的辅助指针，用于两种场景：

- 打破循环引用

- 需要访问共享资源但不影响其生命周期

#### weak_ptr如何升级为shared_ptr？

weak_ptr 通过 lock() 方法安全升级为 shared_ptr，确保访问对象时其未被销毁。

```c++
std::weak_ptr<A> weak_a = ...;  // 从某处获取 weak_ptr

if (auto shared_a = weak_a.lock()) {  // 尝试升级

  shared_a->do_something();    // 对象存活，安全访问

} else {

  // 对象已销毁，避免悬垂指针

}
```

#### unique指针在编译期如何保证是真的unique？

unique_ptr实现真的unique是靠的以下几个机制：

- **禁用拷贝语义**(核心)：unique_ptr 内部将拷贝构造函数和拷贝赋值运算符声明为 = delete，直接禁止复制行为。
- 仅支持移动语义：unique_ptr 允许通过移动操作转移所有权，转移后原指针变为 nullptr。临时右值可隐式移动。

```c++
std::unique_ptr<int> p3 = std::unique_ptr<int>(new int(10)); // 合法
```

- 编译器的静态检查:类型系统强制约束,如当尝试拷贝时，编译器检查到调用了被删除的函数，直接报错。

#### new和malloc的区别？

- **性质**：new是C++操作符，malloc是C语言函数
- **初始化**：new调用构造函数初始化对象，malloc返回未初始化内存
- **语法**：new无需指定大小（如`new int`），malloc需要（如`malloc(sizeof(int))`）
- **返回类型**：new返回具体类型指针，malloc返回void*需强转
- **错误处理**：new抛出std::bad_alloc异常，malloc返回null
- **配对操作**：new配delete，malloc配free
- **实现**：**malloc**的实现核心是通过操作系统提供的系统调用管理堆内存。使用分配的内存块头部存储元数据，通过链表链接所有空闲块。**new**是C++运算符，其行为包含内存分配和对象构造两阶段，内存分配阶段调用全局operator new函数，默认实现内部调用malloc。对象构造阶段用placement new在已分配内存上调用构造函数。new直接返回响应的数据类型的指针。

#### C++堆和栈的区别？

- 堆：堆上的内存是**动态分配**的，程序在运行时可以根据需要分配和释放内存。堆的大小通常比栈⼤得多，因此可以用于存储较⼤的数据结构和对象。

- 栈：栈上的内存⽣命周期与函数调用相关。局部变量在函数被调用时自动分配内存，函数返回时自动释放内存。栈的大小相对较⼩，适用于存储较⼩的数据结构和对象。

#### 如何让对象只能产生在堆/栈上？

对象产生在堆上：将对象的***\*析构函数设置为私有\****的，因为在栈上分配对象的时候，编译器会自动调用对象的构造函数和析构函数，因此此时如果在栈上分配内存会编译报错，就将内存限制在了只能分配在堆上。

对象产生在栈上：把构造函数禁用，使其无法new对象在堆上。

#### C++指针悬挂问题是什么，如何解决？

指针悬挂：指针指向的内存已被释放或失效，但指针仍保留原地址，访问会引发未定义行为。

**常见场景及解决方法**：

- 指针释放后未置空：释放内存后立即置空指针（`p = nullptr`）
- 返回局部变量地址：避免返回局部对象指针/引用，改用动态分配或静态变量
- 容器内存重分配：容器扩容导致原有元素指针失效，避免长期持有容器元素指针
- 多指针共享同一内存：一个指针释放内存后，其他指针也需置空或使用智能指针

## 关键字与语法

#### C++ 指针和引用的区别？

**引用的本质**：引用是对象的别名,从语义上看“不是一个独立对象”。  
在大多数实现中,编译器会用一个隐藏指针来实现引用,因此它通常占用与指针相同的空间,但这属于实现细节,标准并不强制,一般不在代码中依赖 `sizeof(引用)` 的具体值。

指针与引用的区别:

- 指针本身是一个对象,有自己的地址,可以赋值、拷贝,也可以指向不同的对象,还能为 `nullptr`。
- 引用在定义时**必须初始化**,并且一旦绑定某个对象后就不能再改为引用其他对象,通常也不允许“空引用”。
- 使用指针需要显式解引用 `*p` 访问目标对象;引用则可以像普通变量一样直接使用。
- 语义上,指针适合表示“可选/可变的指向关系”(可以为空、可以重指向),引用适合表示“必须存在的别名”,常用于函数参数和返回值以避免拷贝。

#### override和final关键字的作用？

#### 介绍一下static和const？

**Const**：指定语义约束，告诉编译器对象不能被改变，编译器强制检查。

- 可修饰：普通对象（局部/全局）、函数返回值/参数、指针本身/指针指向对象、类成员变量/函数

**Static**：声明静态成员变量、静态成员函数、静态局部变量、静态全局变量。

- **静态成员**：属于类而非对象，所有对象共享，无需对象即可调用
- **静态局部变量**：函数内声明，程序运行期间只初始化一次
- **静态全局变量**：仅在定义文件内可见，避免命名冲突

#### volatile关键字的作用和适用场景？

**作用**：防止编译器优化，强制每次从内存直接读写变量。不保证线程安全，原子操作推荐用atomic。

**适用场景**：

- 硬件寄存器访问：硬件寄存器的值可能被外部设备随时修改（如传感器、GPIO 状态）
- 中断服务程序（ISR）与主程序共享变量：中断可能异步修改变量（如标志位），主程序需感知最新值
- 多线程环境中的简单标志位：用于线程间通知（如退出标志），但不保证线程安全
- 防止空循环被优化

#### C++ inline内联的作用？

**作用**：将代码复制到调用处，消除函数调用开销，提高性能但会导致代码膨胀。

**C++17新特性**：允许多次定义，不同文件中同名inline函数可实现不同功能（类似static）。

#### explicit关键字是什么作用？

explicit 关键字在 C++ 中用于禁止**编译器进行隐式类型转换**，强制要求开发者显式调用构造函数或转换运算符，提高代码的安全性和可读性。

- 禁止隐式类型转换

- 禁止拷贝初始化

- 防止隐式转换链

#### 什么是左值，什么是右值？如何使用

- 左值⼀般是指向⼀个指定内存的，具有名称的值，它通常拥有⼀个稳定的内存地址，并且有⼀段较长时间的声明周期。左值能取到地址，可多次使用。
- 右值通常是不指向稳定内存地址的匿名值，声明周期很短，通常是暂时的。基于此特性，可以用取地址符来判断，右值不能取到地址，通常为一次性使用的值。

#### 前置++返回的是左值还是右值，后置++呢？字符串字面量呢?

- **前置++**：返回左值（直接对对象自增并返回该对象）

- **后置++**：返回右值（创建临时对象保存原值，对原对象自增后返回临时对象）

- **字符串字面量**：返回左值（存储在数据段，有固定内存地址可取址）

#### class和struct的区别？

- class的默认成员和继承都是**private**的，如果要存储一些内部使用的成员变量推荐使用class,因为内部的一些数据不希望被外部随意获取。

- struct默认是**public**的，如果是要给外部提供一些所需的数据可以使用struct。

#### 引用在声明时是否可以不初始化？

**不可以**。引用必须在声明时立即绑定到一个有效对象，否则编译失败。

如果C++的引用在声明时不立刻绑定一个对象会有以下几种情况发生：

- 编译失败：主流编译器如GCC等规定引用在声明时**必须绑定**到一个已存在的有效对象，如果没有不会生成可执行文件。

- 运行时出现未定义行为：若通过某些方式绕过编译检查，会出现访问一块未知内存地址的情况，会出现崩溃、数据损坏等后果。

- 出现悬空引用：引用绑定到临时对象或已被销毁的对象，然后对象被销毁后会出现悬空的情况

## modern C++特性

### C++11

#### 智能指针有没有了解? 三种智能指针讲一下

智能指针是基于 RAII 封装裸指针的类对象,在构造时获取资源,在析构时自动释放资源,避免忘记 delete、异常路径泄露等问题。

- `shared_ptr` : 共享所有权,内部维护引用计数。每次拷贝计数 +1,销毁或 reset 计数 -1,为 0 时自动释放对象。计数本身是线程安全的,但多线程同时读写同一对象仍需加锁。

- `unique_ptr` : 独占所有权,禁止拷贝,只支持移动。同一时间只能有一个 `unique_ptr` 指向该对象,适合唯一拥有者场景,开销最小。

- `weak_ptr` : 不参与所有权,从 `shared_ptr` 构造,只做“旁观者”。不会增加引用计数,常用于解决 `shared_ptr` 之间的循环引用,需要访问时通过 `lock()` 临时升级为 `shared_ptr`。

Tips: `auto_ptr` 已在 C++11 中废弃, C++17 中移除。

#### shared_ptr引用计数的原理是什么？什么时候增加引用计数，什么时候减少引用计数？

**核心原理**：内部维护计数器跟踪指向资源的shared_ptr数量，计数为0时自动释放资源。

**引用计数增加**：创建新shared_ptr、拷贝构造、拷贝赋值时。

**引用计数减少**：对象析构（离开作用域）、reset()、重新赋值时。

### C++14

### C++17

## 模板与泛化

## STL容器

## 多线程与并发

#### 对锁有没有了解,介绍一下？

常见 C++ 锁类型:

- `std::mutex`               : 最基本的互斥锁,不可重入。
- `std::recursive_mutex`     : 可重入互斥锁,同一线程可多次加锁。
- `std::timed_mutex`         : 带超时的互斥锁,支持 `try_lock_for/try_lock_until`。
- `std::recursive_timed_mutex`: 可重入 + 支持超时。
- `std::shared_mutex`        : 读写锁,支持多读单写,适合读多写少场景。
- `std::shared_timed_mutex`  : 在 `shared_mutex` 基础上增加超时功能。

## 编译与链接