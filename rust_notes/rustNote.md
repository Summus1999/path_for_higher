# rust基础学习笔记

rust这个开发语言是一个开源的，然后主要是作为C++的一种更安全的版本，因为它的内存安全是通过编译时检查来实现的，而不是运行时检查。
rust的优势在于他有一个cargo包管理器，帮助我们管理项目的依赖关系，同时也可以帮助我们构建项目。
Rust 项目主要分为两种类型：
- bin:是一个可运行的项目
- lib:是一个依赖库项目。

运行项目分为debug和release版本：
```rust
// debug版本,代码的编译速度会非常快
cargo run
// release版本,代码的运行速度会快
cargo run --release
```

一般使用check指令检查代码是否正确
```rust
cargo check
```

Cargo.toml 和 Cargo.lock 是 cargo 的核心文件，它的所有活动均基于此二者。
- Cargo.toml:是项目的**项目数据描述文件**，它包含了项目的元数据，例如项目名称、版本号、依赖关系等。
- Cargo.lock:是项目的**项目依赖详细清单**，它记录了项目的依赖关系，以及每个依赖的版本号。如果是bin项目就上传git，否则添加到.gitignore 中

变量遮蔽：Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的
```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

tips:
小心**浮点数陷阱！**
- 避免在浮点数上测试相等性
- 浮点数的精度问题当结果在数学上可能存在未定义时，需要格外的小心

同一作用域，特定数据只能有一个可变引用，在编译期就**避免数据竞争**。
```rust
// 编译时会报错,因为在同一作用域内,对s进行了两次可变引用
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s;
println!("{}, {}", r1, r2);
```

大括号可以通过限制作用域帮助解决一些建议不通过的问题。
可变引用与不可变引用**不能同时存在**于同一作用域内。
```rust
// 编译时会报错,因为在同一作用域内,对s进行了可变引用和不可变引用
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &s;
println!("{}, {}", r1, r2);
```

在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。

借用规则如下：
- 同一时刻，你只能拥有要么一个可变引用，要么任意多个不可变引用
- 引用必须总是有效的