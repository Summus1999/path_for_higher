# 二分查找

## leetcode 4  寻找两个正序数组的中位数

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& a, vector<int>& b) {
        if (a.size() > b.size()) {
            swap(a, b);
        }
        int m = a.size(), n = b.size();
        a.insert(a.begin(), INT_MIN);
        b.insert(b.begin(), INT_MIN);
        a.push_back(INT_MAX);
        b.push_back(INT_MAX);
        /*枚举法*/
        int i = 0, j = (m + n + 1) / 2;
        while (true) {
            if (a[i] <= b[j + 1] && a[i + 1] > b[j]) {
                int max1 = max(a[i], b[j]);
                int min2 = min(a[i + 1], b[j + 1]);
                return (m + n) % 2 ? max1 : (max1 + min2) / 2.0;
            }
            i++;
            j--;
        }
    }
};
```

## leetcode 33  搜索旋转排序数组

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int end = nums.back();
        /*构建虚拟数组check*/
        auto check = [&](int i) -> bool {
            int x = nums[i];
            if (x > end) {
                return target > end && x >= target;
            }
            return target > end || x >= target;
        };
        /*进行二分查找*/
        int left = -1;
        int right = nums.size() - 1;
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            if(check(mid)){
                right=mid;
            }else{
                left=mid;
            }
        }
        return nums[right] == target ? right : -1;
    }
};
```

## leetcode 34  在排序数组中查找元素的第一个和最后一个位置

```c++
class Solution {
private:
    int lower_bound(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        /*这里需要加=是因为要找到第一个大于等于target的位置*/
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }

public:
    vector<int> searchRange(vector<int>& nums, int target) {
        /*查找target的起始位置*/
        int start = lower_bound(nums, target);
        if (start == nums.size() || nums[start] != target) {
            return {-1, -1};
        }
        /*查找target+1的起始位置，减1得到target的结束位*/
        int end = lower_bound(nums, target + 1) - 1;
        /*返回找到的起始和结束位置*/
        return {start, end};
    }
};
```

## leetcode  35  搜索插入位置

这道题是比较经典的一道题，是很多二分查找的模板题，如34题可以直接基于本题的代码进行解题。

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int length = nums.size();
        int left = 0;
        int right = length - 1;
        /*二分查找模板题*/
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

## leetcode 69   X的平方根

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0 || x == 1)
            return x;
        int left = 1;
        int right = min(x, 46340);
        int ans = 0;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            /*用除法替代乘法*/
            if (mid <= x / mid) {
                ans = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return ans;
    }
};
```

## leetcode  74  搜索二维矩阵

```c++ 
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        int left = -1;
        int right = m * n;
        /*把矩阵从左上到右下排成一个大数组，进行二分查找即可*/
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            int cur = matrix[mid / n][mid % n];
            if (cur == target) {
                return true;
            }
            if (cur < target) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return false;
    }
};
```

## leetcode  153 寻找旋转排序数组中的最小值

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = -1;
        int right = nums.size() - 1;
        /*和最后一个数比大小，进行二分查找*/
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < nums.back()) {
                right = mid;
            } else
                left = mid;
        }
        return nums[right];
    }
};
```

## leetcode   852   山脉数组的峰顶索引

```c++
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int left = 0;
        int right = arr.size() - 2;
        /*经典二分查找*/
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] > arr[mid + 1]) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

## leetcode  2563   统计公平数对的数目

```c++
class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        ranges::sort(nums);
        long long ans = 0;
        /*遍历每个元素作为右端点 j*/
        for (int j = 0; j < nums.size(); j++) {
            /*注意要在 [0, j-1] 中二分，因为题目要求两个下标 i < j*/
            auto right =
                upper_bound(nums.begin(), nums.begin() + j, upper - nums[j]);
            auto left =
                lower_bound(nums.begin(), nums.begin() + j, lower - nums[j]);
            /*累加数量*/
            ans += right - left;
        }
        return ans;
    }
};
```

## leetcode  2300  咒语和药水的成功对数

```c++
class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions,
                                long long success) {
        ranges::sort(potions);
        for (auto& x : spells) {
            /*计算临界值*/
            long long target = (success - 1) / x;
            /*使用 upper_bound 找到第一个大于 target 的元素位置*/
            if (target < potions.back()) {
                x = potions.end() - ranges::upper_bound(potions, target);
            } else {
                x = 0;
            }
        }
        /*返回结果数组*/
        return spells;
    }
};
```

##  leetcode   1283  使结果不超过阈值的最小除数

```c++
class Solution {
public:
    int smallestDivisor(vector<int>& nums, int threshold) {
        /*给定除数 m，判断 nums 每个元素除以 m 向上取整的和是否 ≤ threshold*/
        auto check = [&](int m) -> bool {
            int sum = 0;
            for (int x : nums) {
                sum += (x + m - 1) / m;
                if (sum > threshold) {
                    return false;
                }
            }
            return true;
        };
        int left = 0;
        int right = ranges::max(nums);
        /*二分查找满足条件的最小除数 m*/
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            (check(mid) ? right : left) = mid;
        }
        return right;
    }
};
```

## leetcode 2187  完成旅途的最小时间

```c++
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        /*给定时间 x，判断是否可以完成至少 totalTrips 次旅程*/
        auto check = [&](long long currentTime) -> bool {
            long long total = 0;
            for (auto t : time) {
                total += currentTime / t;
                if (total >= totalTrips) {
                    return true;
                }
            }
            return false;
        };
        /*找到 time 数组中的最小单次旅程时间*/
        int minTime = ranges::min(time);
        long long left = 0;
        long long right = 1LL * minTime * totalTrips;
        /*寻找满足条件的临界时间*/
        while (right - left > 1) {
            long long mid = left + (right - left) / 2;
            if (check(mid)) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

## leetcode   1011  在 D 天内送达包裹的能力

```c++
class Solution {
public:
    int shipWithinDays(vector<int>& weights, int days) {
        /*确定二分查找左右边界*/
        int left = *max_element(weights.begin(), weights.end());
        int right = accumulate(weights.begin(), weights.end(), 0);
        while (left < right) {
            int mid = (left + right) / 2;
            /*leastDay需要运送的天数*/
            int leastDay = 1;
            int cur = 0;
            for (int weight : weights) {
                if (cur + weight > mid) {
                    ++leastDay;
                    cur = 0;
                }
                cur += weight;
            }
            if (leastDay <= days) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

## leetcode 875  爱吃香蕉的阿珂

```c++
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        auto check = [&](int k) -> bool {
            int sum = piles.size();
            for (auto p : piles) {
                /*计算当前堆能否吃完，吃不完返回FALSE*/
                sum += (p - 1) / k;
                if (sum > h) {
                    return false;
                }
            }
            return true;
        };
        int left = 0;
        int right = ranges::max(piles);
        /*二分查找*/
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            if (check(mid)) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

## leetcode 162  寻找峰值

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = -1;
        int right = nums.size() - 1;
        while (left + 1 < right) {
            auto mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

## leetcode 275  H指数 II

```c++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        int left = 0;
        int right = n - 1;
        /*经典二分查找，注意目标值的区别*/
        while (left <= right) {
            int mid = left + (right - left) / 2;
            /*检查当前论文的引用次数是否足够支撑H指数*/
            if (citations[mid] < n - mid) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return n - left;
    }
};
```

## leetcode 2529  正整数和负整数的最大计数

这题实际上不能算是二分查找，二分查找的写法比较麻烦，没有直接计数的这种写法节约时间。

```c++
class Solution {
public:
    int maximumCount(vector<int>& nums) {
        int n = nums.size();
        int negative = 0;
        int positive = 0;
        /*计算正整数和负整数的个数*/
        for (auto cur : nums) {
            if (cur < 0) {
                negative++;
            }
            if (cur > 0) {
                positive++;
            }
        }
        return max(negative, positive);
    }
};
/*二分查找解法*/
class Solution {
public:
    int maximumCount(vector<int>& nums) {
        int n = nums.size();
        // 查找第一个 >= 0 的索引（负数结束位置）
        int firstNonNeg = firstGreaterEqual(nums, 0);
        // 查找第一个 > 0 的索引（正数开始位置）
        int firstPos = firstGreaterThan(nums, 0);

        int negativeCount = firstNonNeg;  // 负数个数
        int positiveCount = n - firstPos; // 正数个数

        return max(negativeCount, positiveCount);
    }

private:
    // 二分查找：返回第一个 >= target 的索引
    int firstGreaterEqual(vector<int>& nums, int target) {
        int low = 0, high = nums.size();
        while (low < high) {
            int mid = low + (high - low) / 2; // 防溢出
            if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    // 二分查找：返回第一个 > target 的索引
    int firstGreaterThan(vector<int>& nums, int target) {
        int low = 0, high = nums.size();
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }
};
```

## leetcode 2861 最大合金数

```c++
class Solution {
public:
    int maxNumberOfAlloys(int n, int k, int budget,
                          vector<vector<int>>& composition, vector<int>& stock,
                          vector<int>& cost) {
        int ans = 0;
        int maxNum = ranges::min(stock) + budget;
        /*遍历每台机器*/
        for (auto& cur : composition) {
            auto check = [&](long long num) -> bool {
                long long money = 0;
                for (int i = 0; i < n; i++) {
                    /*若库存不足，计算购买费用*/
                    if (stock[i] < cur[i] * num) {
                        money += (cur[i] * num - stock[i]) * cost[i];
                        /*提前终止：花费超预算*/
                        if (money > budget) {
                            return false;
                        }
                    }
                }
                return money <= budget;
            };
            int left = ans;
            int right = maxNum + 1;
            while (right - left > 1) {
                int mid = left + (right - left) / 2;
                /*根据检查结果更新边界*/
                if (check(mid)) {
                    left = mid;
                } else {
                    right = mid;
                }
            }
            ans = left;
        }
        return ans;
    }
};
```

## leetcode 2439  最小化数组中的最大值

```c++
class Solution {
public:
    int minimizeArrayValue(vector<int>& nums) {
        auto check = [&](int limit) -> bool {
            long long extra = 0;
            int n = nums.size();
            for (int i = n - 1; i > 0; i--) {
                extra = max(nums[i] + extra - limit, 0LL);
            }
            return nums[0] + extra - limit <= 0;
        };
        /*开区间二分*/
        int left = -1;
        int right = ranges::max(nums);
        while (right - left > 1) {
            int mid = (left + right) / 2;
            if (check(mid)) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

## leetcode 2517 礼盒的最大甜蜜度

```c++
class Solution {
public:
    int maximumTastiness(vector<int>& price, int k) {
        /*判断是否能在数组中选出k个元素*/
        auto check = [&](int d) -> int {
            int num = 1;
            int pre = price[0];
            for (auto cur : price) {
                if (cur - pre >= d) {
                    num++;
                    pre = cur;
                }
            }
            return num;
        };
        /*排序，确定二分查找边界并进行查找*/
        ranges::sort(price);
        int left = 0;
        int right = (price.back() - price[0]) / (k - 1) + 1;
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            if (check(mid) >= k) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return left;
    }
};
```

## leetcode 1901 寻找峰值 II 

```c++
class Solution {
    /*返回一行中最大值所在的列索引*/
    int indexOfMax(vector<int>& a) {
        return ranges::max_element(a) - a.begin();
    }

public:
    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        int left = -1;
        int n = mat.size();
        int right = n - 1;
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            int j = indexOfMax(mat[mid]);
            /*比较当前行最大值与下一行同列元素*/
            if (mat[mid][j] > mat[mid + 1][j]) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return {right, indexOfMax(mat[right])};
    }
};
```

## leetcode 154 寻找旋转排序数组中的最小值 II

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = -1;
        int n = nums.size();
        int right = n - 1;
        /*二分查找*/
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            /*关键三路比较*/
            if (nums[mid] == nums[right]) {
                right--;
            } else if (nums[mid] < nums[right]) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return nums[right];
    }
};
```

## leetcode 300 最长递增子序列

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        /*贪心+二分*/
        auto end = nums.begin();
        for (auto cur : nums) {
            auto it = lower_bound(nums.begin(), end, cur);
            /*更新该长度下的最小末尾元素,更新有效则长度+1*/
            *it = cur;
            if (it == end) {
                end++;
            }
        }
        return end - nums.begin();
    }
};
```

## leetcode   704  二分查找

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            /*和之前的模板有点不同，要在循环中找到结果就直接输出*/
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
};
```

## leetcode  744   寻找比目标字母大的最小字母

```c++
/*半闭半开区间的写法*/
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        char ans;
        int n = letters.size();
        int left = 0;
        int right = n;
        while (left < right) {
            /*计算中间位置*/
            auto mid = left + (right - left) / 2;
            if (letters[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return letters[left % n];
    }
};
/*闭区间的写法*/
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        int n = letters.size();
        int left = 0;
        int right = n - 1;
        while (left <= right) {
            /*计算中间位置*/
            int mid = left + (right - left) / 2;
            if (letters[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return letters[left % n];
    }
};
```

## leetcode 1385 两个数组间的距离值

```c++
class Solution {
public:
    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
        /*升序排序两个数组*/
        ranges::sort(arr1);
        ranges::sort(arr2);
        int m = arr1.size();
        int n = arr2.size();
        int right = 0;
        int ans = 0;
        /*遍历 arr1 的每个元素*/
        for (int left = 0; left < m; left++) {
            /*移动右指针*/
            while (right < n && arr1[left] - arr2[right] > d) {
                right++;
            }
            if (right == n || arr2[right] - arr1[left] > d) {
                ans++;
            }
        }
        return ans;
    }
};
```
