# 哈希

## Easy

#### 1.两数之和

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        // 创建哈希表
        unordered_map<int, int> hashmap;
        for (int i = 0; i < n; i++) {
            int complement = target - nums[i];
            // 检查补数是否命中
            if (hashmap.find(complement) != hashmap.end()) {
                return {hashmap[complement], i};
            }
            hashmap[nums[i]] = i;
        }
        return {};
    }
};
```

#### 1512.好数对的数目

```c++
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        int ans = 0;
        unordered_map<int, int> hash;
        for (auto cur : nums) {
            // 之前出现过 hash[cur] 次,当前数字cur可以和之前的数字新增
            // count[cur] 对
            ans += hash[cur];
            hash[cur]++;
        }
        return ans;
    }
};
```

## Medium

#### 3.无重复字符的最长子串

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int left = -1;
        int ans = 0;
        // 用数组代替哈希表，进行跳跃搜索
        vector<int> lastSeen(128, -1);
        for (int right = 0; right < n; right++) {
            auto cur = s[right];
            if (lastSeen[cur] > left) {
                // 直接跳到重复字符的右边
                left = lastSeen[cur];
            }
            lastSeen[cur] = right;
            ans = max(ans, right - left);
        }
        return ans;
    }
};
```

#### 451.根据字符出现概率排序

```c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> hashmap;
        int maxFreq = 0;
        // 统计每个字符的频率
        for (auto c : s) {
            maxFreq = max(maxFreq, ++hashmap[c]);
        }
        // 创建桶，索引代表频率，值是具有该频率的所有字符
        vector<vector<char>> buckets(maxFreq + 1);
        for (auto& [ch, freq] : hashmap) {
            buckets[freq].push_back(ch);
        }
        string ans;
        // 从最高频率开始遍历桶
        for (int freq = maxFreq; freq >= 1; freq--) {
            for (auto ch : buckets[freq]) {
                for (int i = 0; i < freq; i++) {
                    ans.push_back(ch);
                }
            }
        }
        return ans;
    }
};
```

#### 692.前K个高频单词

```c++
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        // 统计词频
        unordered_map<string, int> freq;
        for (auto& word : words) {
            freq[word]++;
        }
        // 将单词存入向量以便排序
        vector<string> unique_word;
        for (auto& pair : freq) {
            unique_word.push_back(pair.first);
        }
        // 先按频率降序，频率相同时按字母升序
        sort(unique_word.begin(), unique_word.end(), [&freq](auto& a, auto& b) {
            return freq[a] == freq[b] ? a < b : freq[a] > freq[b];
        });
        // 返回前k个
        return vector<string>(unique_word.begin(), unique_word.begin() + k);
    }
};
```



## Hard



