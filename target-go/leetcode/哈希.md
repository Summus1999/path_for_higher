# 哈希

## Easy

#### 1.两数之和

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        // 创建哈希表
        unordered_map<int, int> hashmap;
        for (int i = 0; i < n; i++) {
            int complement = target - nums[i];
            // 检查补数是否命中
            if (hashmap.find(complement) != hashmap.end()) {
                return {hashmap[complement], i};
            }
            hashmap[nums[i]] = i;
        }
        return {};
    }
};
```

#### 1512.好数对的数目

```c++
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        int ans = 0;
        unordered_map<int, int> hash;
        for (auto cur : nums) {
            // 之前出现过 hash[cur] 次,当前数字cur可以和之前的数字新增
            // count[cur] 对
            ans += hash[cur];
            hash[cur]++;
        }
        return ans;
    }
};
```

## Medium

#### 3.无重复字符的最长子串

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int left = -1;
        int ans = 0;
        // 用数组代替哈希表，进行跳跃搜索
        vector<int> lastSeen(128, -1);
        for (int right = 0; right < n; right++) {
            auto cur = s[right];
            if (lastSeen[cur] > left) {
                // 直接跳到重复字符的右边
                left = lastSeen[cur];
            }
            lastSeen[cur] = right;
            ans = max(ans, right - left);
        }
        return ans;
    }
};
```

#### 451.根据字符出现概率排序

```c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> hashmap;
        int maxFreq = 0;
        // 统计每个字符的频率
        for (auto c : s) {
            maxFreq = max(maxFreq, ++hashmap[c]);
        }
        // 创建桶，索引代表频率，值是具有该频率的所有字符
        vector<vector<char>> buckets(maxFreq + 1);
        for (auto& [ch, freq] : hashmap) {
            buckets[freq].push_back(ch);
        }
        string ans;
        // 从最高频率开始遍历桶
        for (int freq = maxFreq; freq >= 1; freq--) {
            for (auto ch : buckets[freq]) {
                for (int i = 0; i < freq; i++) {
                    ans.push_back(ch);
                }
            }
        }
        return ans;
    }
};
```



## Hard



