# 数组

## Easy

#### 1013.将数组分成和相等的三个部分

```c++
class Solution {
public:
    bool canThreePartsEqualSum(vector<int>& arr) {
        int total = accumulate(arr.begin(), arr.end(), 0);
        if (total % 3 != 0) {
            return false;
        }
        int target = total / 3;
        int findCount = 0;
        int curSum = 0;
        for (auto cur : arr) {
            curSum += cur;
            if (curSum == target) {
                findCount++;
                // 重置，开始下一段
                curSum = 0;
            }
        }
        return findCount >= 3;
    }
};
```

#### 283.移动零

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int write = 0;
        // 原地覆盖非零元素
        for (int read = 0; read < n; read++) {
            if (nums[read] != 0) {
                nums[write] = nums[read];
                write++;
            }
        }
        // 原地将剩余位置置为0
        while (write < n) {
            nums[write] = 0;
            write++;
        }
    }
};

```



## Medium

#### 55.跳跃游戏

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        // 记录当前能够到达的最远下标
        int maxDistance=0;
        for (int i = 0; i < n; i++) {
            // 当前下标已经超出范围返回false
            if (i > maxDistance) {
                return false;
            }
            maxDistance = max(maxDistance, i + nums[i]);
        }
        return true;
    }
};
```

#### 15.三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        ranges::sort(nums);
        int n = nums.size();
        vector<vector<int>> ans;
        for (int i = 0; i < n - 2; i++) {
            int x = nums[i];
            // 去重 a
            if (i > 0 && x == nums[i - 1]) {
                continue;
            }
            // 提前退出：如果最小值都大于0，后面不可能有解
            if (x > 0) {
                break;
            }
            // 剪枝：最小的三个数之和大于0
            if (x + nums[i + 1] + nums[i + 2] > 0) {
                break;
            }
            // 剪枝：当前 a 加上最大的两个数小于0
            if (x + nums[n - 2] + nums[n - 1] < 0) {
                continue;
            }
            int j = i + 1;
            int k = n - 1;
            while (j < k) {
                long long sum = static_cast<long long>(x) + nums[j] + nums[k];
                if (sum < 0) {
                    j++;
                } else if (sum > 0) {
                    k--;
                } else {
                    ans.push_back({x, nums[j], nums[k]});
                    // 去重
                    j++;
                    while (j < k && nums[j] == nums[j - 1]) {
                        j++;
                    }
                    k--;
                    while (j < k && nums[k] == nums[k + 1]) {
                        k--;
                    }
                }
            }
        }
        return ans;
    }
};
```

#### 53.最大子数组和

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 卡丹算法
        int ans = nums[0];
        int currentSum = nums[0];
        int n = nums.size();
        for (int i = 1; i < n; i++) {
            currentSum = max(nums[i], currentSum + nums[i]);
            ans = max(ans, currentSum);
        }
        return ans;
    }
};
```



## Hard

