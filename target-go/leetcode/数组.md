# 数组

## Easy

#### 1013.将数组分成和相等的三个部分

```c++
class Solution {
public:
    bool canThreePartsEqualSum(vector<int>& arr) {
        int total = accumulate(arr.begin(), arr.end(), 0);
        if (total % 3 != 0) {
            return false;
        }
        int target = total / 3;
        int findCount = 0;
        int curSum = 0;
        for (auto cur : arr) {
            curSum += cur;
            if (curSum == target) {
                findCount++;
                // 重置，开始下一段
                curSum = 0;
            }
        }
        return findCount >= 3;
    }
};
```

#### 283.移动零

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int write = 0;
        // 原地覆盖非零元素
        for (int read = 0; read < n; read++) {
            if (nums[read] != 0) {
                nums[write] = nums[read];
                write++;
            }
        }
        // 原地将剩余位置置为0
        while (write < n) {
            nums[write] = 0;
            write++;
        }
    }
};

```

#### 121.买卖股票的最佳时机

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        int minPrice = prices[0];
        int cur = prices[0];
        int n = prices.size();
        for (int i = 0; i < n; i++) {
            cur = prices[i];
            // 更新最大利润ans和最低价格minPrice
            ans = max(ans, cur - minPrice);
            minPrice = min(minPrice, cur);
        }
        return ans;
    }
};
```

#### 88.合并两个有序数组

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // 初始化三个指针
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        // 从后往前比较和填充
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k] = nums1[i];
                i--;
            } else {
                nums1[k] = nums2[j];
                j--;
            }
            k--;
        }
        // 剩余元素复制到nums1
        while (j >= 0) {
            nums1[k] = nums2[j];
            j--;
            k--;
        }
    }
};
```



## Medium

#### 55.跳跃游戏

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        // 记录当前能够到达的最远下标
        int maxDistance=0;
        for (int i = 0; i < n; i++) {
            // 当前下标已经超出范围返回false
            if (i > maxDistance) {
                return false;
            }
            maxDistance = max(maxDistance, i + nums[i]);
        }
        return true;
    }
};
```

#### 15.三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        ranges::sort(nums);
        int n = nums.size();
        vector<vector<int>> ans;
        for (int i = 0; i < n - 2; i++) {
            int x = nums[i];
            // 去重 a
            if (i > 0 && x == nums[i - 1]) {
                continue;
            }
            // 提前退出：如果最小值都大于0，后面不可能有解
            if (x > 0) {
                break;
            }
            // 剪枝：最小的三个数之和大于0
            if (x + nums[i + 1] + nums[i + 2] > 0) {
                break;
            }
            // 剪枝：当前 a 加上最大的两个数小于0
            if (x + nums[n - 2] + nums[n - 1] < 0) {
                continue;
            }
            int j = i + 1;
            int k = n - 1;
            while (j < k) {
                long long sum = static_cast<long long>(x) + nums[j] + nums[k];
                if (sum < 0) {
                    j++;
                } else if (sum > 0) {
                    k--;
                } else {
                    ans.push_back({x, nums[j], nums[k]});
                    // 去重
                    j++;
                    while (j < k && nums[j] == nums[j - 1]) {
                        j++;
                    }
                    k--;
                    while (j < k && nums[k] == nums[k + 1]) {
                        k--;
                    }
                }
            }
        }
        return ans;
    }
};
```

#### 53.最大子数组和

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 卡丹算法
        int ans = nums[0];
        int currentSum = nums[0];
        int n = nums.size();
        for (int i = 1; i < n; i++) {
            currentSum = max(nums[i], currentSum + nums[i]);
            ans = max(ans, currentSum);
        }
        return ans;
    }
};
```



## Hard

