# 二叉树

## Easy

#### 94.二叉树的中序遍历

```c++
class Solution {
    // 递归遍历左右子树
    void Traversal(TreeNode* node, vector<int>& vec) {
        if (!node) {
            return;
        }
        Traversal(node->left, vec);
        vec.push_back(node->val);
        Traversal(node->right, vec);
    }

public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        Traversal(root, ans);
        return ans;
    }
};
```

#### 101.对称二叉树

```c++
class Solution {
    bool isSame(TreeNode* p, TreeNode* q) {
        if (!p || !q) {
            return p == q;
        }
        return (p->val == q->val) && isSame(p->left, q->right) &&
               isSame(p->right, q->left);
    }

public:
    bool isSymmetric(TreeNode* root) { return isSame(root->left, root->right); }
};
```

#### 104.二叉树的最大深度

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        // 引入中间变量，让逻辑更清晰，也方便编译器优化
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        return max(leftDepth, rightDepth) + 1;
    }
};
```

#### 110.平衡二叉树

```c++
class Solution {
    int getHeight(TreeNode* node) {
        if (node == nullptr) {
            return 0;
        }
        int leftHeight = getHeight(node->left);
        if (leftHeight == -1) {
            return -1;
        }
        int rightHeight = getHeight(node->right);
        if (rightHeight == -1 || abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        return max(leftHeight, rightHeight) + 1;
    }

public:
    bool isBalanced(TreeNode* root) {
        // 后序遍历+信息复用
        return getHeight(root) != -1;
    }
};
```

#### 144.二叉树的前序遍历

```c++
class Solution {
    void traversal(TreeNode* node, vector<int>& vec) {
        if (!node) {
            return;
        }
        vec.push_back(node->val);
        traversal(node->left, vec);
        traversal(node->right, vec);
    }

public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        traversal(root, ans);
        return ans;
    }
};
```



## Medium

## Hard

