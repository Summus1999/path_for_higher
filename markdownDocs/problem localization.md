# problem localization

## 性能

#### 如何排查C++代码在计算部分的性能瓶颈？

排查思路：

1. 宏观定位热点区域
   - 使用性能分析工具采样，找出占用CPU时间最多的模块或函数
   - 确定性能瓶颈所在的大致范围

2. 微观分析热点函数
   - 对热点函数进行详细的调用分析和时间统计
   - 分析函数内部各部分的耗时分布

3. 代码级瓶颈定位
   - 定位到具体的代码行或语句
   - 分析算法复杂度、缓存命中率、分支预测等因素

常用工具：

- perf：Linux下的性能分析工具，支持CPU采样、事件统计、火焰图生成
- Hotspot：perf的可视化前端，提供直观的性能数据展示
- VTune：Intel的性能分析工具，提供更详细的硬件层面分析
- valgrind：内存分析工具，可检测内存泄漏、缓存命中率等问题

## 调试

#### gdb的watch是如何实现的？看的是内存地址还是检测值是否变化？

GDB 中的 watch 命令通过**监控指定内存地址的内容变化实现断点触发**，其核心原理分为硬件辅助和软件模拟两种方式。

- 硬件辅助实现：**依赖CPU调试寄存器**，现代处理器（如x86的DR0-DR7寄存器）支持设置内存访问断点，监视地址，watch 将目标变量或表达式的内存地址写入调试寄存器。当出现读写等操作时，触发SIGTRAP异常，GDB捕获该异常并暂停程序，显示变化前后的值。
- 软件模拟：当硬件不支持或寄存器不足时，GDB在每条指令执行后，对比目标地址的当前值与之前快照。

## 内存

#### 如何定位C++内存泄漏问题？C++如何避免内存泄漏问题？

定位手段：

1. ASan（AddressSanitizer）
   - 编译时插桩，运行时检测内存错误
   - 开销较小，适合开发阶段持续使用
   - 能快速定位内存泄漏、越界访问等问题

2. Valgrind（Memcheck工具）
   - 无需重新编译，通过虚拟机监控内存操作
   - 提供详细的内存泄漏报告，包括泄漏位置和调用栈
   - 运行开销大，主要用于深度分析

3. Heaptrack
   - 可视化的堆内存分析工具
   - 提供内存分配的时间线和调用图
   - 适合分析内存增长趋势和定位泄漏源头

C++内存泄漏防范手段：

1. 遵循RAII原则
   - 资源获取即初始化，利用对象生命周期自动管理资源
   - 使用智能指针（unique_ptr、shared_ptr）替代裸指针
   - 让编译器和运行时自动处理资源释放

2. 避免循环引用
   - shared_ptr循环引用会导致内存无法释放
   - 使用weak_ptr打破循环引用
   - 设计时注意对象间的依赖关系

3. 统一资源管理策略
   - 明确对象所有权，避免多处释放或忘记释放
   - 优先使用容器和标准库组件
   - 减少手动new/delete的使用

4. 开发阶段持续检测
   - 在CI/CD中集成ASan等检测工具
   - 定期使用Valgrind进行深度检查
   - 关注内存使用趋势，及早发现异常
   
#### core dump是什么，如何使用gdb看core dump文件？

Core dump（核心转储）是程序崩溃时操作系统自动生成的磁盘文件，它保存了程序崩溃瞬间的完整内存快照、寄存器状态、函数调用栈等上下文信息，相当于程序“事故现场的黑匣子。无需修改代码或添加日志，直接分析崩溃瞬间状态。

看core dump文件的过程：(需要编译时候带上符号)
先生成core dump文件

```bash
ulimit -c unlimited  # 解除大小限制
```

- 加载 core 文件
- 使用调试命令查看文件