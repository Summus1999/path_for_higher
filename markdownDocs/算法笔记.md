# 算法笔记

这篇笔记是我之前刷题总结的一些写法,基本只记录最优解,本文档的目的就是为了跳槽找工作,因此是按解法思路和题目难度进行划分.

## 一、数组与双指针

### Easy

#### 88.合并两个有序数组

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // 从后往前比较和填充，避免覆盖nums1中的有效元素
        int i = m - 1, j = n - 1, k = m + n - 1;
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        // 剩余元素复制到nums1
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
};
```

#### 121.买卖股票的最佳时机

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0, minPrice = prices[0];
        for (int i = 1; i < prices.size(); i++) {
            // 更新最大利润和最低价格
            ans = max(ans, prices[i] - minPrice);
            minPrice = min(minPrice, prices[i]);
        }
        return ans;
    }
};
```

#### 283.移动零

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int write = 0;
        // 原地覆盖非零元素
        for (int read = 0; read < n; read++) {
            if (nums[read] != 0) {
                nums[write++] = nums[read];
            }
        }
        // 剩余位置置为0
        while (write < n) {
            nums[write++] = 0;
        }
    }
};
```

#### 26.删除有序数组中的重复项

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) return 0;
        int slow = 1;
        // fast遇到新元素就赋值给slow
        for (int fast = 1; fast < nums.size(); fast++) {
            if (nums[fast] != nums[fast - 1]) {
                nums[slow++] = nums[fast];
            }
        }
        return slow;
    }
};
```

#### 27.移除元素

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0;
        for (int right = 0; right < nums.size(); right++) {
            if (nums[right] != val) {
                nums[left++] = nums[right];
            }
        }
        return left;
    }
};
```

#### 35.搜索插入位置

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        // 二分查找模板：找第一个>=target的位置
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

#### 169.多数元素

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        // 排序后下标为n/2的必定是多数元素
        ranges::sort(nums);
        return nums[nums.size() / 2];
    }
};
```

#### 217.存在重复元素

```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> seen;
        for (int num : nums) {
            if (seen.count(num)) return true;
            seen.insert(num);
        }
        return false;
    }
};
```

#### 136.只出现一次的数字

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        // 异或运算：相同为0，不同为1
        for (int num : nums) {
            ans ^= num;
        }
        return ans;
    }
};
```

### Medium

#### 15.三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int i = 0; i < n - 2; i++) {
            // 去重
            if (nums[i] > 0) {
                break;
            }
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            // 剪枝
            if (nums[i] + nums[i + 1] + nums[i + 2] > 0) {
                break;
            }
            if (nums[i] + nums[n - 2] + nums[n - 1] < 0) {
                continue;
            }
            int j = i + 1;
            int k = n - 1;
            while (j < k) {
                long long sum = (long long)nums[i] + nums[j] + nums[k];
                if (sum < 0) {
                    j++;
                } else if (sum > 0) {
                    k--;
                } else {
                    ans.push_back({nums[i], nums[j], nums[k]});
                    // 去重
                    while (j < k && nums[j] == nums[j + 1]) {
                        j++;
                    }
                    while (j < k && nums[k] == nums[k - 1]) {
                        k--;
                    }
                    j++;
                    k--;
                }
            }
        }
        return ans;
    }
};
```

#### 11.盛最多水的容器

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int ans = 0;
        while (left < right) {
            // 计算面积，矮边向内移动
            int area = (right - left) * min(height[left], height[right]);
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
            ans = max(ans, area);
        }
        return ans;
    }
};
```

#### 42.接雨水

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        int left = 0;
        int right = height.size() - 1;
        int prefix = 0;
        int suffix = 0;
        while (left < right) {
            prefix = max(prefix, height[left]);
            suffix = max(suffix, height[right]);
            // 处理高度较小的一侧
            if (height[left] < height[right]) {
                ans += prefix - height[left];
                left++;
            } else {
                ans += suffix - height[right];
                right--;
            }
        }
        return ans;
    }
};
```

#### 16.最接近的三数之和

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        ranges::sort(nums);
        int ans = nums[0] + nums[1] + nums[2];
        for (int i = 0; i < nums.size() - 2; i++) {
            int j = i + 1, k = nums.size() - 1;
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (abs(sum - target) < abs(ans - target)) {
                    ans = sum;
                }
                if (sum < target) j++;
                else if (sum > target) k--;
                else return target;
            }
        }
        return ans;
    }
};
```

#### 18.四数之和

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int a = 0; a < n - 3; a++) {
            if (a > 0 && nums[a] == nums[a - 1]) continue;
            for (int b = a + 1; b < n - 2; b++) {
                if (b > a + 1 && nums[b] == nums[b - 1]) continue;
                int c = b + 1, d = n - 1;
                while (c < d) {
                    long long sum = (long long)nums[a] + nums[b] + nums[c] + nums[d];
                    if (sum < target) c++;
                    else if (sum > target) d--;
                    else {
                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});
                        while (c < d && nums[c] == nums[c + 1]) c++;
                        while (c < d && nums[d] == nums[d - 1]) d--;
                        c++; d--;
                    }
                }
            }
        }
        return ans;
    }
};
```

#### 31.下一个排列

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        // 1. 从后往前找第一个降序位置
        int i = nums.size() - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) i--;
        // 2. 如果存在，从后往前找第一个比nums[i]大的数
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[j] <= nums[i]) j--;
            swap(nums[i], nums[j]);
        }
        // 3. 反转i+1到末尾
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```

#### 33.搜索旋转排序数组

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            // 判断哪半边有序
            if (nums[left] <= nums[mid]) {
                // 左半边有序
                if (target >= nums[left] && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                // 右半边有序
                if (target > nums[mid] && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
};
```

#### 34.在排序数组中查找元素的第一个和最后一个位置

```c++
class Solution {
    int lowerBound(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int start = lowerBound(nums, target);
        if (start == nums.size() || nums[start] != target) return {-1, -1};
        int end = lowerBound(nums, target + 1) - 1;
        return {start, end};
    }
};
```

#### 53.最大子数组和

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 卡丹算法
        int ans = nums[0], curSum = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            // 要么重新开始，要么延续
            curSum = max(nums[i], curSum + nums[i]);
            ans = max(ans, curSum);
        }
        return ans;
    }
};
```

#### 55.跳跃游戏

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int maxReach = 0;
        for (int i = 0; i < nums.size(); i++) {
            // 当前位置已经超出可达范围
            if (i > maxReach) return false;
            maxReach = max(maxReach, i + nums[i]);
        }
        return true;
    }
};
```

#### 45.跳跃游戏II

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int ans = 0, curEnd = 0, nextEnd = 0;
        for (int i = 0; i < nums.size() - 1; i++) {
            nextEnd = max(nextEnd, i + nums[i]);
            // 到达当前边界，必须跳一步
            if (i == curEnd) {
                ans++;
                curEnd = nextEnd;
            }
        }
        return ans;
    }
};
```

#### 56.合并区间

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        ranges::sort(intervals);
        vector<vector<int>> ans;
        for (auto& interval : intervals) {
            if (ans.empty() || interval[0] > ans.back()[1]) {
                ans.push_back(interval);
            } else {
                ans.back()[1] = max(ans.back()[1], interval[1]);
            }
        }
        return ans;
    }
};
```

#### 189.轮转数组

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k %= nums.size();
        // 三次反转
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin() + k);
        reverse(nums.begin() + k, nums.end());
    }
};
```

#### 75.颜色分类

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        // 荷兰国旗问题：三指针
        int left = 0, right = nums.size() - 1;
        for (int i = 0; i <= right; i++) {
            if (nums[i] == 0) {
                swap(nums[i], nums[left++]);
            } else if (nums[i] == 2) {
                swap(nums[i--], nums[right--]);
            }
        }
    }
};
```

#### 80.删除有序数组中的重复项II

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 2) return nums.size();
        int slow = 2;
        for (int fast = 2; fast < nums.size(); fast++) {
            if (nums[fast] != nums[slow - 2]) {
                nums[slow++] = nums[fast];
            }
        }
        return slow;
    }
};
```

#### 152.乘积最大子数组

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        // 同时维护最大和最小（负数可能变最大）
        int maxF = nums[0], minF = nums[0], ans = nums[0];
        for (int i = 1; i < n; i++) {
            int mx = maxF, mn = minF;
            maxF = max({nums[i], mx * nums[i], mn * nums[i]});
            minF = min({nums[i], mx * nums[i], mn * nums[i]});
            ans = max(ans, maxF);
        }
        return ans;
    }
};
```

#### 153.寻找旋转排序数组中的最小值

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            // 和最后一个元素比较
            if (nums[mid] < nums[right]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return nums[left];
    }
};
```

#### 238.除自身以外数组的乘积

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 1);
        // 先计算前缀积
        for (int i = 1; i < n; i++) {
            ans[i] = ans[i - 1] * nums[i - 1];
        }
        // 再计算后缀积
        int suffix = 1;
        for (int i = n - 2; i >= 0; i--) {
            suffix *= nums[i + 1];
            ans[i] *= suffix;
        }
        return ans;
    }
};
```

#### 334.递增的三元子序列

```c++
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int first = INT_MAX, second = INT_MAX;
        for (int num : nums) {
            if (num <= first) {
                first = num;
            } else if (num <= second) {
                second = num;
            } else {
                return true; // 找到第三个数
            }
        }
        return false;
    }
};
```

#### 380.O(1)时间插入、删除和获取随机元素

```c++
class RandomizedSet {
    vector<int> nums;
    unordered_map<int, int> indexMap;
public:
    bool insert(int val) {
        if (indexMap.count(val)) return false;
        indexMap[val] = nums.size();
        nums.push_back(val);
        return true;
    }
    
    bool remove(int val) {
        if (!indexMap.count(val)) return false;
        int last = nums.back();
        int idx = indexMap[val];
        // 用最后一个元素覆盖
        nums[idx] = last;
        indexMap[last] = idx;
        nums.pop_back();
        indexMap.erase(val);
        return true;
    }
    
    int getRandom() {
        return nums[rand() % nums.size()];
    }
};
```

#### 435.无重叠区间

```c++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        ranges::sort(intervals, [](auto& a, auto& b) {
            return a[1] < b[1];
        });
        int ans = 0, end = intervals[0][1];
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] < end) {
                ans++; // 有重叠，需要移除
            } else {
                end = intervals[i][1];
            }
        }
        return ans;
    }
};
```

#### 487.最大连续1的个数II

```c++
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int left = 0, zeros = 0, ans = 0;
        for (int right = 0; right < nums.size(); right++) {
            if (nums[right] == 0) zeros++;
            while (zeros > 1) {
                if (nums[left++] == 0) zeros--;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

### Hard

#### 41.缺失的第一个正数

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        // 原地哈希：把数字放到正确的位置
        for (int i = 0; i < n; i++) {
            while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) return i + 1;
        }
        return n + 1;
    }
};
```

#### 154.寻找旋转排序数组中的最小值II

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else if (nums[mid] < nums[right]) {
                right = mid;
            } else {
                right--; // 去重
            }
        }
        return nums[left];
    }
};
```

---

## 二、滑动窗口

### Easy

#### 209.长度最小的子数组

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0, sum = 0, ans = INT_MAX;
        for (int right = 0; right < nums.size(); right++) {
            sum += nums[right];
            while (sum >= target) {
                ans = min(ans, right - left + 1);
                sum -= nums[left++];
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```

### Medium

#### 3.无重复字符的最长子串

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> hash;
        int left = 0;
        int n = s.size();
        int ans = 0;
        for (int right = 0; right < n; right++) {
            hash[s[right]]++;
            // 出现重复，收缩左边界
            while (hash[s[right]] > 1) {
                hash[s[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

#### 76.最小覆盖子串

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        int need[128] = {}, window[128] = {};
        for (char c : t) need[c]++;
        
        int left = 0, valid = 0;
        int start = 0, len = INT_MAX;
        
        for (int right = 0; right < s.size(); right++) {
            char c = s[right];
            if (need[c] > 0) {
                window[c]++;
                if (window[c] == need[c]) valid++;
            }
            // 收缩窗口
            while (valid == t.size()) {
                if (right - left + 1 < len) {
                    start = left;
                    len = right - left + 1;
                }
                char d = s[left++];
                if (need[d] > 0) {
                    if (window[d] == need[d]) valid--;
                    window[d]--;
                }
            }
        }
        return len == INT_MAX ? "" : s.substr(start, len);
    }
};
```

#### 239.滑动窗口最大值

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> ans(n - k + 1);
        deque<int> q;
        for (int i = 0; i < n; i++) {
            // 右边入维护单调性
            while (!q.empty() && nums[q.back()] <= nums[i]) {
                q.pop_back();
            }
            q.push_back(i);
            // 左边出清理过期索引
            int left = i - k + 1;
            if (q.front() < left) {
                q.pop_front();
            }
            // 在窗口左端点处记录答案
            if (left >= 0) {
                ans[left] = nums[q.front()];
            }
        }
        return ans;
    }
};
```

#### 424.替换后的最长重复字符

```c++
class Solution {
public:
    int characterReplacement(string s, int k) {
        int count[26] = {};
        int left = 0, maxCount = 0, ans = 0;
        for (int right = 0; right < s.size(); right++) {
            maxCount = max(maxCount, ++count[s[right] - 'A']);
            // 需要替换的字符数 = 窗口大小 - 最频繁的字符数
            while (right - left + 1 - maxCount > k) {
                count[s[left++] - 'A']--;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

#### 567.字符串的排列

```c++
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int need[26] = {}, window[26] = {};
        for (char c : s1) need[c - 'a']++;
        int left = 0, valid = 0;
        for (int right = 0; right < s2.size(); right++) {
            int c = s2[right] - 'a';
            window[c]++;
            if (window[c] == need[c]) valid++;
            // 窗口大小固定为s1.size()
            if (right >= s1.size()) {
                int d = s2[left++] - 'a';
                if (window[d] == need[d]) valid--;
                window[d]--;
            }
            if (valid == 26) return true;
        }
        return false;
    }
};
```

#### 904.水果成篮

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> count;
        int left = 0, ans = 0;
        for (int right = 0; right < fruits.size(); right++) {
            count[fruits[right]]++;
            while (count.size() > 2) {
                if (--count[fruits[left]] == 0) count.erase(fruits[left]);
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

#### 1004.最大连续1的个数III

```c++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int left = 0, zeros = 0, ans = 0;
        for (int right = 0; right < nums.size(); right++) {
            if (nums[right] == 0) zeros++;
            while (zeros > k) {
                if (nums[left++] == 0) zeros--;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

#### 1052.爱生气的书店老板

```c++
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int n = customers.size();
        int base = 0, extra = 0, maxExtra = 0;
        for (int i = 0; i < n; i++) {
            if (grumpy[i] == 0) base += customers[i];
            if (i < minutes) {
                extra += grumpy[i] * customers[i];
            } else {
                extra += grumpy[i] * customers[i] - grumpy[i - minutes] * customers[i - minutes];
            }
            maxExtra = max(maxExtra, extra);
        }
        return base + maxExtra;
    }
};
```

#### 1423.可获得的最大点数

```c++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        int total = accumulate(cardPoints.begin(), cardPoints.end(), 0);
        int windowSize = n - k;
        int minWindowSum = INT_MAX, curSum = 0;
        for (int i = 0; i < n; i++) {
            curSum += cardPoints[i];
            if (i >= windowSize) curSum -= cardPoints[i - windowSize];
            if (i >= windowSize - 1) minWindowSum = min(minWindowSum, curSum);
        }
        return total - minWindowSum;
    }
};
```

#### 1658.将X减到0的最小操作数

```c++
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int total = accumulate(nums.begin(), nums.end(), 0);
        int target = total - x;
        if (target < 0) return -1;
        
        int left = 0, curSum = 0, maxLen = -1;
        for (int right = 0; right < nums.size(); right++) {
            curSum += nums[right];
            while (curSum > target) curSum -= nums[left++];
            if (curSum == target) maxLen = max(maxLen, right - left + 1);
        }
        return maxLen == -1 ? -1 : nums.size() - maxLen;
    }
};
```

---

## 三、链表

### Easy

#### 21.合并两个有序链表

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy(0);
        ListNode* cur = &dummy;
        while (list1 && list2) {
            if (list1->val <= list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2;
        return dummy.next;
    }
};
```

#### 206.反转链表

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = nullptr, *cur = head;
        while (cur) {
            ListNode* next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
};
```

#### 141.环形链表

```c++
class Solution {
public:
    bool hasCycle(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) return true;
        }
        return false;
    }
};
```

#### 160.相交链表

```c++
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode *pA = headA, *pB = headB;
        while (pA != pB) {
            pA = pA ? pA->next : headB;
            pB = pB ? pB->next : headA;
        }
        return pA;
    }
};
```

#### 203.移除链表元素

```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode dummy(0, head);
        ListNode* cur = &dummy;
        while (cur->next) {
            if (cur->next->val == val) {
                cur->next = cur->next->next;
            } else {
                cur = cur->next;
            }
        }
        return dummy.next;
    }
};
```

#### 83.删除排序链表中的重复元素

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head) return head;
        ListNode* cur = head;
        while (cur->next) {
            if (cur->val == cur->next->val) {
                cur->next = cur->next->next;
            } else {
                cur = cur->next;
            }
        }
        return head;
    }
};
```

#### 237.删除链表中的节点

```c++
class Solution {
public:
    void deleteNode(ListNode* node) {
        // 用下一个节点覆盖当前节点
        *node = *node->next;
    }
};
```

#### 876.链表的中间结点

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};
```

### Medium

#### 2.两数相加

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);
        ListNode* cur = &dummy;
        int carry = 0;
        while (l1 || l2 || carry) {
            int sum = carry;
            if (l1) { sum += l1->val; l1 = l1->next; }
            if (l2) { sum += l2->val; l2 = l2->next; }
            cur->next = new ListNode(sum % 10);
            carry = sum / 10;
            cur = cur->next;
        }
        return dummy.next;
    }
};
```

#### 19.删除链表的倒数第N个结点

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode dummy(0, head);
        ListNode *fast = &dummy, *slow = &dummy;
        // fast先走n+1步
        for (int i = 0; i <= n; i++) fast = fast->next;
        // 一起走到末尾
        while (fast) {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummy.next;
    }
};
```

#### 24.两两交换链表中的节点

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode dummy(0, head);
        ListNode* cur = &dummy;
        while (cur->next && cur->next->next) {
            ListNode *first = cur->next;
            ListNode *second = cur->next->next;
            // 交换
            first->next = second->next;
            second->next = first;
            cur->next = second;
            cur = first;
        }
        return dummy.next;
    }
};
```

#### 92.反转链表II

```c++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode dummy(0, head);
        ListNode* pre = &dummy;
        // 走到left前一个
        for (int i = 1; i < left; i++) pre = pre->next;
        
        ListNode* cur = pre->next;
        // 头插法反转
        for (int i = 0; i < right - left; i++) {
            ListNode* next = cur->next;
            cur->next = next->next;
            next->next = pre->next;
            pre->next = next;
        }
        return dummy.next;
    }
};
```

#### 142.环形链表II

```c++
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                // 相遇后，从头和相遇点同时走
                ListNode* ptr = head;
                while (ptr != slow) {
                    ptr = ptr->next;
                    slow = slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
    }
};
```

#### 143.重排链表

```c++
class Solution {
    ListNode* reverse(ListNode* head) {
        ListNode *prev = nullptr, *cur = head;
        while (cur) {
            ListNode* next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
public:
    void reorderList(ListNode* head) {
        if (!head || !head->next) return;
        // 1. 找中点
        ListNode *slow = head, *fast = head;
        while (fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        // 2. 反转后半部分
        ListNode* l2 = reverse(slow->next);
        slow->next = nullptr;
        // 3. 合并
        ListNode* l1 = head;
        while (l1 && l2) {
            ListNode* next1 = l1->next;
            ListNode* next2 = l2->next;
            l1->next = l2;
            l2->next = next1;
            l1 = next1;
            l2 = next2;
        }
    }
};
```

#### 148.排序链表

```c++
class Solution {
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);
        ListNode* cur = &dummy;
        while (l1 && l2) {
            if (l1->val < l2->val) {
                cur->next = l1;
                l1 = l1->next;
            } else {
                cur->next = l2;
                l2 = l2->next;
            }
            cur = cur->next;
        }
        cur->next = l1 ? l1 : l2;
        return dummy.next;
    }
public:
    ListNode* sortList(ListNode* head) {
        if (!head || !head->next) return head;
        // 找中点
        ListNode *slow = head, *fast = head->next;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        ListNode* mid = slow->next;
        slow->next = nullptr;
        // 归并排序
        return merge(sortList(head), sortList(mid));
    }
};
```

#### 25.K个一组翻转链表

```c++
class Solution {
    ListNode* reverse(ListNode* head, ListNode* tail) {
        ListNode *prev = tail->next, *cur = head;
        while (prev != tail) {
            ListNode* next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        return tail;
    }
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode dummy(0, head);
        ListNode* pre = &dummy;
        while (head) {
            ListNode* tail = pre;
            // 检查是否有k个节点
            for (int i = 0; i < k; i++) {
                tail = tail->next;
                if (!tail) return dummy.next;
            }
            ListNode* next = tail->next;
            // 反转
            head = reverse(head, tail);
            pre->next = tail;
            head->next = next;
            pre = head;
            head = next;
        }
        return dummy.next;
    }
};
```

#### 138.随机链表的复制

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head) return nullptr;
        // 1. 复制节点，插入到原节点后面
        for (Node* cur = head; cur; cur = cur->next->next) {
            Node* copy = new Node(cur->val);
            copy->next = cur->next;
            cur->next = copy;
        }
        // 2. 设置random指针
        for (Node* cur = head; cur; cur = cur->next->next) {
            if (cur->random) {
                cur->next->random = cur->random->next;
            }
        }
        // 3. 分离两个链表
        Node* newHead = head->next;
        for (Node* cur = head; cur; cur = cur->next) {
            Node* copy = cur->next;
            cur->next = copy->next;
            if (copy->next) copy->next = copy->next->next;
        }
        return newHead;
    }
};
```

#### 146.LRU缓存

```c++
class LRUCache {
    struct Node {
        int key, val;
        Node *prev, *next;
        Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}
    };
    
    unordered_map<int, Node*> cache;
    Node* head;
    Node* tail;
    int capacity;
    int size;
    
    void remove(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    
    void addToHead(Node* node) {
        node->next = head->next;
        node->prev = head;
        head->next->prev = node;
        head->next = node;
    }
    
    void moveToHead(Node* node) {
        remove(node);
        addToHead(node);
    }
    
    Node* removeTail() {
        Node* node = tail->prev;
        remove(node);
        return node;
    }
    
public:
    LRUCache(int capacity) : capacity(capacity), size(0) {
        head = new Node();
        tail = new Node();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if (!cache.count(key)) return -1;
        Node* node = cache[key];
        moveToHead(node);
        return node->val;
    }
    
    void put(int key, int value) {
        if (cache.count(key)) {
            Node* node = cache[key];
            node->val = value;
            moveToHead(node);
        } else {
            Node* node = new Node(key, value);
            cache[key] = node;
            addToHead(node);
            size++;
            if (size > capacity) {
                Node* removed = removeTail();
                cache.erase(removed->key);
                delete removed;
                size--;
            }
        }
    }
};
```

#### 82.删除排序链表中的重复元素II

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode dummy(0, head);
        ListNode* cur = &dummy;
        while (cur->next && cur->next->next) {
            if (cur->next->val == cur->next->next->val) {
                int val = cur->next->val;
                while (cur->next && cur->next->val == val) {
                    cur->next = cur->next->next;
                }
            } else {
                cur = cur->next;
            }
        }
        return dummy.next;
    }
};
```

#### 234.回文链表

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        // 1. 找中点
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        // 2. 反转后半部分
        ListNode *prev = nullptr, *cur = slow;
        while (cur) {
            ListNode* next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        // 3. 比较
        while (prev) {
            if (head->val != prev->val) return false;
            head = head->next;
            prev = prev->next;
        }
        return true;
    }
};
```

#### 23.合并K个升序链表

```c++
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);
        for (auto head : lists) {
            if (head) pq.push(head);
        }
        ListNode dummy(0);
        ListNode* cur = &dummy;
        while (!pq.empty()) {
            ListNode* node = pq.top(); pq.pop();
            cur->next = node;
            cur = cur->next;
            if (node->next) pq.push(node->next);
        }
        return dummy.next;
    }
};
```

#### 445.两数相加II

```c++
class Solution {
    ListNode* reverse(ListNode* head) {
        ListNode *prev = nullptr, *cur = head;
        while (cur) {
            ListNode* next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        l1 = reverse(l1);
        l2 = reverse(l2);
        ListNode* head = nullptr;
        int carry = 0;
        while (l1 || l2 || carry) {
            int sum = carry;
            if (l1) { sum += l1->val; l1 = l1->next; }
            if (l2) { sum += l2->val; l2 = l2->next; }
            ListNode* node = new ListNode(sum % 10);
            node->next = head;
            head = node;
            carry = sum / 10;
        }
        return head;
    }
};
```



---

## 四、二叉树

### Easy

#### 104.二叉树的最大深度

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

#### 100.相同的树

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p || !q) return p == q;
        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

#### 101.对称二叉树

```c++
class Solution {
    bool check(TreeNode* p, TreeNode* q) {
        if (!p || !q) return p == q;
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
    }
public:
    bool isSymmetric(TreeNode* root) {
        return check(root->left, root->right);
    }
};
```

#### 94.二叉树的中序遍历

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur || !st.empty()) {
            while (cur) {
                st.push(cur);
                cur = cur->left;
            }
            cur = st.top(); st.pop();
            ans.push_back(cur->val);
            cur = cur->right;
        }
        return ans;
    }
};
```

#### 226.翻转二叉树

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) return nullptr;
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
        root->left = right;
        root->right = left;
        return root;
    }
};
```

#### 112.路径总和

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (!root) return false;
        if (!root->left && !root->right) return targetSum == root->val;
        return hasPathSum(root->left, targetSum - root->val) || 
               hasPathSum(root->right, targetSum - root->val);
    }
};
```

#### 700.二叉搜索树中的搜索

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root && root->val != val) {
            root = val < root->val ? root->left : root->right;
        }
        return root;
    }
};
```

#### 572.另一棵树的子树

```c++
class Solution {
    bool isSame(TreeNode* p, TreeNode* q) {
        if (!p || !q) return p == q;
        return p->val == q->val && isSame(p->left, q->left) && isSame(p->right, q->right);
    }
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if (!root) return false;
        return isSame(root, subRoot) || isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
    }
};
```

### Medium

#### 102.二叉树的层序遍历

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if (!root) return {};
        vector<vector<int>> ans;
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int size = q.size();
            vector<int> level;
            for (int i = 0; i < size; i++) {
                TreeNode* node = q.front(); q.pop();
                level.push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            ans.push_back(level);
        }
        return ans;
    }
};
```

#### 103.二叉树的锯齿形层序遍历

```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        if (!root) return {};
        vector<vector<int>> ans;
        queue<TreeNode*> q;
        q.push(root);
        bool leftToRight = true;
        while (!q.empty()) {
            int size = q.size();
            vector<int> level(size);
            for (int i = 0; i < size; i++) {
                TreeNode* node = q.front(); q.pop();
                int idx = leftToRight ? i : size - 1 - i;
                level[idx] = node->val;
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            ans.push_back(level);
            leftToRight = !leftToRight;
        }
        return ans;
    }
};
```

#### 105.从前序与中序遍历序列构造二叉树

```c++
class Solution {
    unordered_map<int, int> indexMap;
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); i++) indexMap[inorder[i]] = i;
        return build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
    }
    
    TreeNode* build(vector<int>& preorder, int preL, int preR, 
                    vector<int>& inorder, int inL, int inR) {
        if (preL > preR) return nullptr;
        int rootVal = preorder[preL];
        int rootIdx = indexMap[rootVal];
        int leftSize = rootIdx - inL;
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preL + 1, preL + leftSize, inorder, inL, rootIdx - 1);
        root->right = build(preorder, preL + leftSize + 1, preR, inorder, rootIdx + 1, inR);
        return root;
    }
};
```

#### 106.从中序与后序遍历序列构造二叉树

```c++
class Solution {
    unordered_map<int, int> indexMap;
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for (int i = 0; i < inorder.size(); i++) indexMap[inorder[i]] = i;
        return build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);
    }
    
    TreeNode* build(vector<int>& inorder, int inL, int inR,
                    vector<int>& postorder, int postL, int postR) {
        if (postL > postR) return nullptr;
        int rootVal = postorder[postR];
        int rootIdx = indexMap[rootVal];
        int rightSize = inR - rootIdx;
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(inorder, inL, rootIdx - 1, postorder, postL, postR - rightSize - 1);
        root->right = build(inorder, rootIdx + 1, inR, postorder, postR - rightSize, postR - 1);
        return root;
    }
};
```

#### 114.二叉树展开为链表

```c++
class Solution {
public:
    void flatten(TreeNode* root) {
        if (!root) return;
        // 保存左右子树
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        // 左子树置空，右子树接上原来的左子树
        root->left = nullptr;
        root->right = left;
        // 找到当前右子树的末尾
        TreeNode* cur = root;
        while (cur->right) cur = cur->right;
        // 接上原来的右子树
        cur->right = right;
        // 递归处理
        flatten(root->right);
    }
};
```

#### 98.验证二叉搜索树

```c++
class Solution {
    TreeNode* prev = nullptr;
public:
    bool isValidBST(TreeNode* root) {
        if (!root) return true;
        if (!isValidBST(root->left)) return false;
        if (prev && prev->val >= root->val) return false;
        prev = root;
        return isValidBST(root->right);
    }
};
```

#### 230.二叉搜索树中第K小的元素

```c++
class Solution {
    int count = 0, ans = 0;
public:
    int kthSmallest(TreeNode* root, int k) {
        inorder(root, k);
        return ans;
    }
    void inorder(TreeNode* root, int k) {
        if (!root) return;
        inorder(root->left, k);
        count++;
        if (count == k) {
            ans = root->val;
            return;
        }
        inorder(root->right, k);
    }
};
```

#### 236.二叉树的最近公共祖先

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left && right) return root;
        return left ? left : right;
    }
};
```

#### 235.二叉搜索树的最近公共祖先

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        if (p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);
        return root;
    }
};
```

#### 199.二叉树的右视图

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        dfs(root, 0, ans);
        return ans;
    }
    void dfs(TreeNode* root, int depth, vector<int>& ans) {
        if (!root) return;
        if (depth == ans.size()) ans.push_back(root->val);
        dfs(root->right, depth + 1, ans);
        dfs(root->left, depth + 1, ans);
    }
};
```

#### 113.路径总和II

```c++
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        vector<vector<int>> ans;
        vector<int> path;
        dfs(root, targetSum, path, ans);
        return ans;
    }
    void dfs(TreeNode* root, int target, vector<int>& path, vector<vector<int>>& ans) {
        if (!root) return;
        path.push_back(root->val);
        if (!root->left && !root->right && target == root->val) {
            ans.push_back(path);
        }
        dfs(root->left, target - root->val, path, ans);
        dfs(root->right, target - root->val, path, ans);
        path.pop_back();
    }
};
```

#### 129.求根节点到叶节点数字之和

```c++
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return dfs(root, 0);
    }
    int dfs(TreeNode* root, int sum) {
        if (!root) return 0;
        sum = sum * 10 + root->val;
        if (!root->left && !root->right) return sum;
        return dfs(root->left, sum) + dfs(root->right, sum);
    }
};
```

#### 437.路径总和III

```c++
class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {
        unordered_map<long long, int> prefix;
        prefix[0] = 1;
        return dfs(root, 0, targetSum, prefix);
    }
    int dfs(TreeNode* root, long long curSum, int target, unordered_map<long long, int>& prefix) {
        if (!root) return 0;
        curSum += root->val;
        int ans = prefix[curSum - target];
        prefix[curSum]++;
        ans += dfs(root->left, curSum, target, prefix);
        ans += dfs(root->right, curSum, target, prefix);
        prefix[curSum]--;
        return ans;
    }
};
```

#### 124.二叉树中的最大路径和

```c++
class Solution {
    int ans = INT_MIN;
public:
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return ans;
    }
    int dfs(TreeNode* root) {
        if (!root) return 0;
        int left = max(0, dfs(root->left));
        int right = max(0, dfs(root->right));
        ans = max(ans, left + right + root->val);
        return max(left, right) + root->val;
    }
};
```

#### 538.把二叉搜索树转换为累加树

```c++
class Solution {
    int sum = 0;
public:
    TreeNode* convertBST(TreeNode* root) {
        if (!root) return nullptr;
        convertBST(root->right);
        sum += root->val;
        root->val = sum;
        convertBST(root->left);
        return root;
    }
};
```

---

## 五、动态规划

### Easy

#### 70.爬楼梯

```c++
class Solution {
public:
    int climbStairs(int n) {
        // 特殊情况处理
        if (n <= 1) {
            return 1;
        }
        int dp_i_minus_1 = 1;
        int dp_i_minus_2 = 1;
        int ans = 0;
        // fn=f(n-1)+f(n-2)
        for (int i = 1; i < n; i++) {
            ans = dp_i_minus_1 + dp_i_minus_2;
            dp_i_minus_1 = dp_i_minus_2;
            dp_i_minus_2 = ans;
        }
        return ans;
    }
};
```

#### 746.使用最小花费爬楼梯

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> memory(n, -1);
        // 定义记忆化搜索
        function<int(int)> dfs = [&](int i) -> int {
            if (i >= n) {
                return 0;
            }
            if (memory[i] != -1) {
                return memory[i];
            }
            // 选爬1步还是2步
            memory[i] = cost[i] + min(dfs(i + 1), dfs(i + 2));
            return memory[i];
        };
        return min(dfs(0), dfs(1));
    }
};
```

#### 3693.使用最小花费爬楼梯III

```c++
class Solution {
public:
    int climbStairs(int n, vector<int>& costs) {
        vector<int> memory(n + 1);
        // 自底向上计算
        for (int i = 1; i <= n; i++) {
            int ans = INT_MAX;
            for (int j = max(i - 3, 0); j < i; j++) {
                ans = min(ans, memory[j] + (i - j) * (i - j));
            }
            memory[i] = ans + costs[i - 1];
        }
        return memory[n];
    }
};
```

#### 53.最大子数组和

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n);
        f[0] = nums[0];
        // 动态规划递推
        for (int i = 1; i < n; i++) {
            f[i] = max(f[i - 1], 0) + nums[i];
        }
        return ranges::max(f);
    }
};
```

#### 118.杨辉三角

```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> ans;
        for (int i = 0; i < numRows; i++) {
            vector<int> row(i + 1, 1);
            for (int j = 1; j < i; j++) {
                row[j] = ans[i - 1][j - 1] + ans[i - 1][j];
            }
            ans.push_back(row);
        }
        return ans;
    }
};
```

#### 121.买卖股票的最佳时机

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minPrice = prices[0], maxProfit = 0;
        for (int i = 1; i < prices.size(); i++) {
            maxProfit = max(maxProfit, prices[i] - minPrice);
            minPrice = min(minPrice, prices[i]);
        }
        return maxProfit;
    }
};
```

### Medium

#### 198.打家劫舍

**解法一：迭代DP（空间优化）**

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];
        int prev2 = nums[0], prev1 = max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            int cur = max(prev1, prev2 + nums[i]);
            prev2 = prev1;
            prev1 = cur;
        }
        return prev1;
    }
};
```

**解法二：记忆化搜索（C++23）**

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> memory(n, -1);
        // 从最后一个房子开始搜，计算最多能偷多少
        auto dfs = [&](this auto&& dfs, int i) -> int {
            if (i < 0) {
                return 0;
            }
            if (memory[i] != -1) {
                return memory[i];
            }
            return memory[i] = max(dfs(i - 1), dfs(i - 2) + nums[i]);
        };
        return dfs(n - 1);
    }
};
```

#### 213.打家劫舍II

**解法一：区间DP（闭区间）**

```c++
class Solution {
    int robRange(vector<int>& nums, int start, int end) {
        int prev2 = 0, prev1 = 0;
        for (int i = start; i <= end; i++) {
            int cur = max(prev1, prev2 + nums[i]);
            prev2 = prev1;
            prev1 = cur;
        }
        return prev1;
    }
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];
        // 偷第一家就不偷最后一家，反之亦然
        return max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));
    }
};
```

**解法二：半开区间写法**

```c++
class Solution {
    // 计算最大偷窃金额
    int subRob(vector<int>& nums, int start, int end) {
        int f0 = 0, f1 = 0;
        for (int i = start; i < end; i++) {
            int new_f = max(f1, f0 + nums[i]);
            f0 = f1;
            f1 = new_f;
        }
        return f1;
    }
public:
    int rob(vector<int>& nums) {
        // 环形问题拆解为两个线性子问题：偷不偷第一家
        int n = nums.size();
        return max(nums[0] + subRob(nums, 2, n - 1), subRob(nums, 1, n));
    }
};
```

#### 337.打家劫舍III

```c++
class Solution {
    unordered_map<TreeNode*, int> memo;
public:
    int rob(TreeNode* root) {
        if (!root) return 0;
        if (memo.count(root)) return memo[root];
        // 偷当前节点
        int doRob = root->val;
        if (root->left) doRob += rob(root->left->left) + rob(root->left->right);
        if (root->right) doRob += rob(root->right->left) + rob(root->right->right);
        // 不偷当前节点
        int notRob = rob(root->left) + rob(root->right);
        memo[root] = max(doRob, notRob);
        return memo[root];
    }
};
```

#### 279.完全平方数

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j * j <= i; j++) {
                dp[i] = min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
};
```

#### 300.最长递增子序列

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // 贪心 + 二分
        vector<int> tails;
        for (int num : nums) {
            auto it = lower_bound(tails.begin(), tails.end(), num);
            if (it == tails.end()) tails.push_back(num);
            else *it = num;
        }
        return tails.size();
    }
};
```

#### 322.零钱兑换

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, amount + 1);
        dp[0] = 0;
        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] = min(dp[i], dp[i - coin] + 1);
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
};
```

#### 416.分割等和子集

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % 2) return false;
        int target = sum / 2;
        vector<bool> dp(target + 1, false);
        dp[0] = true;
        for (int num : nums) {
            for (int i = target; i >= num; i--) {
                dp[i] = dp[i] || dp[i - num];
            }
        }
        return dp[target];
    }
};
```

#### 494.目标和

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        // 正数和为pos，负数和为sum-pos，pos-(sum-pos)=target -> 2*pos=sum+target
        if ((sum + target) % 2 || sum < abs(target)) return 0;
        int pos = (sum + target) / 2;
        vector<int> dp(pos + 1);
        dp[0] = 1;
        for (int num : nums) {
            for (int i = pos; i >= num; i--) {
                dp[i] += dp[i - num];
            }
        }
        return dp[pos];
    }
};
```

#### 1143.最长公共子序列

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
};
```

#### 72.编辑距离

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 0; i <= m; i++) dp[i][0] = i;
        for (int j = 0; j <= n; j++) dp[0][j] = j;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
                }
            }
        }
        return dp[m][n];
    }
};
```

#### 139.单词拆分

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> words(wordDict.begin(), wordDict.end());
        int n = s.size();
        vector<bool> dp(n + 1, false);
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && words.count(s.substr(j, i - j))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
};
```

#### 152.乘积最大子数组

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int maxF = nums[0], minF = nums[0], ans = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            int mx = maxF, mn = minF;
            maxF = max({nums[i], mx * nums[i], mn * nums[i]});
            minF = min({nums[i], mx * nums[i], mn * nums[i]});
            ans = max(ans, maxF);
        }
        return ans;
    }
};
```

#### 309.买卖股票的最佳时机含冷冻期

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        // 0:持有，1:冷冻期，2:不持有
        vector<vector<int>> dp(n, vector<int>(3));
        dp[0][0] = -prices[0];
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
            dp[i][1] = dp[i - 1][0] + prices[i];
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1]);
        }
        return max(dp[n - 1][1], dp[n - 1][2]);
    }
};
```

#### 188.买卖股票的最佳时机IV

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        // 如果k很大，相当于无限次交易
        if (k >= n / 2) {
            int ans = 0;
            for (int i = 1; i < n; i++) {
                if (prices[i] > prices[i - 1]) ans += prices[i] - prices[i - 1];
            }
            return ans;
        }
        // dp[i][j][0/1]:第i天，完成了j次交易，是否持有股票
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(k + 1, vector<int>(2, -1e9)));
        dp[0][0][0] = 0;
        dp[0][0][1] = -prices[0];
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
                if (j > 0) dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
            }
        }
        int ans = 0;
        for (int j = 0; j <= k; j++) ans = max(ans, dp[n - 1][j][0]);
        return ans;
    }
};
```

#### 516.最长回文子序列

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j < n; j++) {
                if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2;
                else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
        return dp[0][n - 1];
    }
};
```

#### 62.不同路径

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n, 1);
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
};
```

#### 64.最小路径和

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n));
        dp[0][0] = grid[0][0];
        for (int i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];
        for (int j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

#### 120.三角形最小路径和

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<int> dp = triangle[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j];
            }
        }
        return dp[0];
    }
};
```

#### 221.最大正方形

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        int maxSide = 0;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (matrix[i - 1][j - 1] == '1') {
                    dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
                    maxSide = max(maxSide, dp[i][j]);
                }
            }
        }
        return maxSide * maxSide;
    }
};
```

#### 131.分割回文串

```c++
class Solution {
    vector<vector<bool>> isPal;
    vector<vector<string>> ans;
    vector<string> path;
    
    void preprocess(const string& s) {
        int n = s.size();
        isPal.assign(n, vector<bool>(n, true));
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                isPal[i][j] = (s[i] == s[j]) && isPal[i + 1][j - 1];
            }
        }
    }
    
    void backtrack(const string& s, int start) {
        if (start == s.size()) {
            ans.push_back(path);
            return;
        }
        for (int i = start; i < s.size(); i++) {
            if (isPal[start][i]) {
                path.push_back(s.substr(start, i - start + 1));
                backtrack(s, i + 1);
                path.pop_back();
            }
        }
    }
    
public:
    vector<vector<string>> partition(string s) {
        preprocess(s);
        backtrack(s, 0);
        return ans;
    }
};
```

### Hard

#### 32.最长有效括号

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        vector<int> dp(n);
        int ans = 0;
        for (int i = 1; i < n; i++) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {
                    dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] >= 2 ? dp[i - dp[i - 1] - 2] : 0);
                }
                ans = max(ans, dp[i]);
            }
        }
        return ans;
    }
};
```

#### 5.最长回文子串

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        int start = 0, maxLen = 1;
        vector<vector<bool>> dp(n, vector<bool>(n, true));
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                dp[i][j] = (s[i] == s[j]) && dp[i + 1][j - 1];
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    start = i;
                }
            }
        }
        return s.substr(start, maxLen);
    }
};
```

#### 10.正则表达式匹配

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
        dp[0][0] = true;
        for (int j = 1; j <= n; j++) {
            if (p[j - 1] == '*') dp[0][j] = dp[0][j - 2];
        }
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p[j - 1] == '*') {
                    dp[i][j] = dp[i][j - 2];
                    if (matches(s, p, i, j - 1)) {
                        dp[i][j] = dp[i][j] || dp[i - 1][j];
                    }
                } else if (matches(s, p, i, j)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
        return dp[m][n];
    }
    bool matches(string& s, string& p, int i, int j) {
        if (p[j - 1] == '.') return true;
        return s[i - 1] == p[j - 1];
    }
};
```

#### 123.买卖股票的最佳时机III

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int buy1 = -prices[0], sell1 = 0;
        int buy2 = -prices[0], sell2 = 0;
        for (int i = 1; i < prices.size(); i++) {
            buy1 = max(buy1, -prices[i]);
            sell1 = max(sell1, buy1 + prices[i]);
            buy2 = max(buy2, sell1 - prices[i]);
            sell2 = max(sell2, buy2 + prices[i]);
        }
        return sell2;
    }
};
```

#### 312.戳气球

```c++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        vector<int> points(n + 2, 1);
        for (int i = 0; i < n; i++) points[i + 1] = nums[i];
        vector<vector<int>> dp(n + 2, vector<int>(n + 2));
        for (int len = 3; len <= n + 2; len++) {
            for (int i = 0; i <= n + 2 - len; i++) {
                int j = i + len - 1;
                for (int k = i + 1; k < j; k++) {
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + points[i] * points[k] * points[j]);
                }
            }
        }
        return dp[0][n + 1];
    }
};
```



---

## 六、回溯

### Medium

#### 17.电话号码的字母组合

```c++
class Solution {
    const string MAP[10] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
public:
    vector<string> letterCombinations(string digits) {
        if (digits.empty()) return {};
        vector<string> ans;
        string path;
        backtrack(digits, 0, path, ans);
        return ans;
    }
    void backtrack(string& digits, int index, string& path, vector<string>& ans) {
        if (index == digits.size()) {
            ans.push_back(path);
            return;
        }
        for (char c : MAP[digits[index] - '0']) {
            path.push_back(c);
            backtrack(digits, index + 1, path, ans);
            path.pop_back();
        }
    }
};
```

#### 22.括号生成

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> ans;
        string path;
        backtrack(n, n, path, ans);
        return ans;
    }
    void backtrack(int left, int right, string& path, vector<string>& ans) {
        if (left == 0 && right == 0) {
            ans.push_back(path);
            return;
        }
        if (left > 0) {
            path.push_back('(');
            backtrack(left - 1, right, path, ans);
            path.pop_back();
        }
        if (right > left) {
            path.push_back(')');
            backtrack(left, right - 1, path, ans);
            path.pop_back();
        }
    }
};
```

#### 39.组合总和

```c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> path;
        backtrack(candidates, target, 0, path, ans);
        return ans;
    }
    void backtrack(vector<int>& candidates, int target, int start, vector<int>& path, vector<vector<int>>& ans) {
        if (target == 0) {
            ans.push_back(path);
            return;
        }
        if (target < 0) return;
        for (int i = start; i < candidates.size(); i++) {
            path.push_back(candidates[i]);
            backtrack(candidates, target - candidates[i], i, path, ans);
            path.pop_back();
        }
    }
};
```

#### 40.组合总和II

```c++
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        ranges::sort(candidates);
        vector<vector<int>> ans;
        vector<int> path;
        backtrack(candidates, target, 0, path, ans);
        return ans;
    }
    void backtrack(vector<int>& candidates, int target, int start, vector<int>& path, vector<vector<int>>& ans) {
        if (target == 0) {
            ans.push_back(path);
            return;
        }
        for (int i = start; i < candidates.size(); i++) {
            if (i > start && candidates[i] == candidates[i - 1]) continue;
            if (candidates[i] > target) break;
            path.push_back(candidates[i]);
            backtrack(candidates, target - candidates[i], i + 1, path, ans);
            path.pop_back();
        }
    }
};
```

#### 46.全排列

```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ans;
        backtrack(nums, 0, ans);
        return ans;
    }
    void backtrack(vector<int>& nums, int start, vector<vector<int>>& ans) {
        if (start == nums.size()) {
            ans.push_back(nums);
            return;
        }
        for (int i = start; i < nums.size(); i++) {
            swap(nums[start], nums[i]);
            backtrack(nums, start + 1, ans);
            swap(nums[start], nums[i]);
        }
    }
};
```

#### 47.全排列II

```c++
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        vector<bool> used(nums.size());
        vector<int> path;
        backtrack(nums, used, path, ans);
        return ans;
    }
    void backtrack(vector<int>& nums, vector<bool>& used, vector<int>& path, vector<vector<int>>& ans) {
        if (path.size() == nums.size()) {
            ans.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) continue;
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue;
            used[i] = true;
            path.push_back(nums[i]);
            backtrack(nums, used, path, ans);
            path.pop_back();
            used[i] = false;
        }
    }
};
```

#### 77.组合

```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> path;
        backtrack(n, k, 1, path, ans);
        return ans;
    }
    void backtrack(int n, int k, int start, vector<int>& path, vector<vector<int>>& ans) {
        if (path.size() == k) {
            ans.push_back(path);
            return;
        }
        for (int i = start; i <= n; i++) {
            path.push_back(i);
            backtrack(n, k, i + 1, path, ans);
            path.pop_back();
        }
    }
};
```

#### 78.子集

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> ans;
        vector<int> path;
        backtrack(nums, 0, path, ans);
        return ans;
    }
    void backtrack(vector<int>& nums, int start, vector<int>& path, vector<vector<int>>& ans) {
        ans.push_back(path);
        for (int i = start; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backtrack(nums, i + 1, path, ans);
            path.pop_back();
        }
    }
};
```

#### 90.子集II

```c++
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        vector<int> path;
        backtrack(nums, 0, path, ans);
        return ans;
    }
    void backtrack(vector<int>& nums, int start, vector<int>& path, vector<vector<int>>& ans) {
        ans.push_back(path);
        for (int i = start; i < nums.size(); i++) {
            if (i > start && nums[i] == nums[i - 1]) continue;
            path.push_back(nums[i]);
            backtrack(nums, i + 1, path, ans);
            path.pop_back();
        }
    }
};
```

#### 79.单词搜索

```c++
class Solution {
    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
public:
    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size(), n = board[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (backtrack(board, word, i, j, 0)) return true;
            }
        }
        return false;
    }
    bool backtrack(vector<vector<char>>& board, string& word, int i, int j, int k) {
        if (k == word.size()) return true;
        if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size()) return false;
        if (board[i][j] != word[k]) return false;
        char tmp = board[i][j];
        board[i][j] = '#';
        for (auto& dir : dirs) {
            int ni = i + dir[0], nj = j + dir[1];
            if (backtrack(board, word, ni, nj, k + 1)) return true;
        }
        board[i][j] = tmp;
        return false;
    }
};
```

#### 93.复原IP地址

```c++
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        vector<string> ans;
        string path;
        backtrack(s, 0, 0, path, ans);
        return ans;
    }
    void backtrack(string& s, int start, int part, string& path, vector<string>& ans) {
        if (part == 4) {
            if (start == s.size()) ans.push_back(path.substr(0, path.size() - 1));
            return;
        }
        for (int i = 1; i <= 3 && start + i <= s.size(); i++) {
            string segment = s.substr(start, i);
            if (segment[0] == '0' && i > 1) continue;
            if (stoi(segment) > 255) continue;
            path += segment + ".";
            backtrack(s, start + i, part + 1, path, ans);
            path.resize(path.size() - i - 1);
        }
    }
};
```

#### 216.组合总和III

```c++
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> ans;
        vector<int> path;
        backtrack(k, n, 1, path, ans);
        return ans;
    }
    void backtrack(int k, int n, int start, vector<int>& path, vector<vector<int>>& ans) {
        if (path.size() == k) {
            if (n == 0) ans.push_back(path);
            return;
        }
        for (int i = start; i <= 9; i++) {
            if (i > n) break;
            path.push_back(i);
            backtrack(k, n - i, i + 1, path, ans);
            path.pop_back();
        }
    }
};
```

### Hard

#### 51.N皇后

```c++
class Solution {
    vector<vector<string>> ans;
    vector<string> board;
    vector<bool> cols, diag1, diag2;
public:
    vector<vector<string>> solveNQueens(int n) {
        board.assign(n, string(n, '.'));
        cols.assign(n, false);
        diag1.assign(2 * n - 1, false);
        diag2.assign(2 * n - 1, false);
        backtrack(0, n);
        return ans;
    }
    void backtrack(int row, int n) {
        if (row == n) {
            ans.push_back(board);
            return;
        }
        for (int col = 0; col < n; col++) {
            int d1 = row - col + n - 1, d2 = row + col;
            if (cols[col] || diag1[d1] || diag2[d2]) continue;
            board[row][col] = 'Q';
            cols[col] = diag1[d1] = diag2[d2] = true;
            backtrack(row + 1, n);
            board[row][col] = '.';
            cols[col] = diag1[d1] = diag2[d2] = false;
        }
    }
};
```

#### 37.解数独

```c++
class Solution {
    bool rows[9][9] = {}, cols[9][9] = {}, boxes[9][9] = {};
public:
    void solveSudoku(vector<vector<char>>& board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    int num = board[i][j] - '1';
                    rows[i][num] = cols[j][num] = boxes[i / 3 * 3 + j / 3][num] = true;
                }
            }
        }
        backtrack(board, 0, 0);
    }
    bool backtrack(vector<vector<char>>& board, int i, int j) {
        if (i == 9) return true;
        if (j == 9) return backtrack(board, i + 1, 0);
        if (board[i][j] != '.') return backtrack(board, i, j + 1);
        for (int num = 0; num < 9; num++) {
            int box = i / 3 * 3 + j / 3;
            if (rows[i][num] || cols[j][num] || boxes[box][num]) continue;
            board[i][j] = '1' + num;
            rows[i][num] = cols[j][num] = boxes[box][num] = true;
            if (backtrack(board, i, j + 1)) return true;
            board[i][j] = '.';
            rows[i][num] = cols[j][num] = boxes[box][num] = false;
        }
        return false;
    }
};
```

---

## 七、图论

### Medium

#### 200.岛屿数量

**解法一：传统DFS**

```c++
class Solution {
    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
public:
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    ans++;
                    dfs(grid, i, j);
                }
            }
        }
        return ans;
    }
    void dfs(vector<vector<char>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') return;
        grid[i][j] = '0';
        for (auto& dir : dirs) {
            dfs(grid, i + dir[0], j + dir[1]);
        }
    }
};
```

**解法二：C++23显式递归lambda**

```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        int ans = 0;
        auto dfs = [&](this auto&& dfs, int i, int j) -> void {
            if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') {
                return;
            }
            grid[i][j] = '2';
            dfs(i - 1, j);
            dfs(i + 1, j);
            dfs(i, j - 1);
            dfs(i, j + 1);
        };
        // 双重循环扫描每个单元格
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    dfs(i, j);
                    ans++;
                }
            }
        }
        return ans;
    }
};
```

#### 695.岛屿的最大面积

```c++
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        int ans = 0;
        // 递归搜索岛屿
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != 1) {
                return 0;
            }
            grid[i][j] = 2;
            return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) +
                   dfs(i, j + 1);
        };
        // 遍历每个网格单元
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    ans = max(ans, dfs(i, j));
                }
            }
        }
        return ans;
    }
};
```

#### 3619.总价值可以被 K 整除的岛屿数目

```c++
class Solution {
public:
    int countIslands(vector<vector<int>>& grid, int k) {
        int m = grid.size();
        int n = grid[0].size();
        int ans = 0;
        // 遍历岛屿
        auto dfs = [&](this auto&& dfs, int i, int j) -> long long {
            if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] <= 0) {
                return 0;
            }
            long long val = grid[i][j];
            grid[i][j] = -1;
            return val + dfs(i, j + 1) + dfs(i, j - 1) + dfs(i + 1, j) +
                   dfs(i - 1, j);
        };
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 正整数是陆地
                if (grid[i][j] > 0) {
                    long long totalValue = dfs(i, j);
                    if (totalValue % k == 0) {
                        ans++;
                    }
                }
            }
        }
        return ans;
    }
};
```

#### 2658.网格图中鱼的最大数目

```c++
class Solution {
public:
    int findMaxFish(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        int ans = 0;
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] <= 0) {
                return 0;
            }
            int val = grid[i][j];
            grid[i][j] = -1;
            return val + dfs(i, j + 1) + dfs(i, j - 1) + dfs(i - 1, j) +
                   dfs(i + 1, j);
        };
        // 遍历所有鱼群
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                ans = max(ans, dfs(i, j));
            }
        }
        return ans;
    }
};
```

#### 207.课程表

```c++
class Solution {
    bool hasCycle = false;
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> graph(numCourses);
        vector<int> state(numCourses, 0); // 0:未访问，1:访问中，2:已访问
        for (auto& p : prerequisites) {
            graph[p[1]].push_back(p[0]);
        }
        for (int i = 0; i < numCourses; i++) {
            if (state[i] == 0) dfs(graph, state, i);
        }
        return !hasCycle;
    }
    void dfs(vector<vector<int>>& graph, vector<int>& state, int u) {
        if (hasCycle) return;
        state[u] = 1;
        for (int v : graph[u]) {
            if (state[v] == 1) {
                hasCycle = true;
                return;
            }
            if (state[v] == 0) dfs(graph, state, v);
        }
        state[u] = 2;
    }
};
```

#### 210.课程表II

```c++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> graph(numCourses);
        vector<int> indegree(numCourses);
        for (auto& p : prerequisites) {
            graph[p[1]].push_back(p[0]);
            indegree[p[0]]++;
        }
        queue<int> q;
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) q.push(i);
        }
        vector<int> ans;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            ans.push_back(u);
            for (int v : graph[u]) {
                if (--indegree[v] == 0) q.push(v);
            }
        }
        return ans.size() == numCourses ? ans : vector<int>();
    }
};
```

#### 994.腐烂的橘子

```c++
class Solution {
    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        queue<pair<int, int>> q;
        int fresh = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 2) q.push({i, j});
                else if (grid[i][j] == 1) fresh++;
            }
        }
        int minutes = 0;
        while (!q.empty() && fresh > 0) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                auto [x, y] = q.front(); q.pop();
                for (auto& dir : dirs) {
                    int nx = x + dir[0], ny = y + dir[1];
                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1) {
                        grid[nx][ny] = 2;
                        fresh--;
                        q.push({nx, ny});
                    }
                }
            }
            minutes++;
        }
        return fresh == 0 ? minutes : -1;
    }
};
```

---

## 八、栈与队列

### Easy

#### 20.有效的括号

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for (char c : s) {
            if (c == '(') st.push(')');
            else if (c == '[') st.push(']');
            else if (c == '{') st.push('}');
            else {
                if (st.empty() || st.top() != c) return false;
                st.pop();
            }
        }
        return st.empty();
    }
};
```

#### 155.最小栈

```c++
class MinStack {
    stack<long long> st;
    long long minVal;
public:
    MinStack() {}
    
    void push(int val) {
        if (st.empty()) {
            st.push(0);
            minVal = val;
        } else {
            st.push(val - minVal);
            if (val < minVal) minVal = val;
        }
    }
    
    void pop() {
        long long diff = st.top(); st.pop();
        if (diff < 0) minVal -= diff;
    }
    
    int top() {
        long long diff = st.top();
        return diff >= 0 ? minVal + diff : minVal;
    }
    
    int getMin() {
        return minVal;
    }
};
```

#### 232.用栈实现队列

```c++
class MyQueue {
    stack<int> in, out;
public:
    MyQueue() {}
    
    void push(int x) {
        in.push(x);
    }
    
    int pop() {
        peek();
        int ans = out.top(); out.pop();
        return ans;
    }
    
    int peek() {
        if (out.empty()) {
            while (!in.empty()) {
                out.push(in.top()); in.pop();
            }
        }
        return out.top();
    }
    
    bool empty() {
        return in.empty() && out.empty();
    }
};
```

### Medium

#### 739.每日温度

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> ans(n);
        // 单调递减栈
        stack<int> st;
        for (int i = n - 1; i >= 0; i--) {
            int cur = temperatures[i];
            // 弹出栈中所有 ≤ 当前温度的索引
            while (!st.empty() && cur >= temperatures[st.top()]) {
                st.pop();
            }
            // 栈顶即为右侧第一个更高温度的位置，计算等待天数
            if (!st.empty()) {
                ans[i] = st.top() - i;
            }
            st.push(i);
        }
        return ans;
    }
};
```

#### 84.柱状图中最大的矩形

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        heights.push_back(0);
        stack<int> st;
        st.push(-1);
        int ans = 0;
        for (int i = 0; i < heights.size(); i++) {
            while (st.top() != -1 && heights[i] < heights[st.top()]) {
                int h = heights[st.top()]; st.pop();
                ans = max(ans, h * (i - st.top() - 1));
            }
            st.push(i);
        }
        return ans;
    }
};
```

#### 394.字符串解码

```c++
class Solution {
public:
    string decodeString(string s) {
        stack<string> strSt;
        stack<int> numSt;
        string curStr;
        int num = 0;
        for (char c : s) {
            if (isdigit(c)) {
                num = num * 10 + (c - '0');
            } else if (c == '[') {
                strSt.push(curStr);
                numSt.push(num);
                curStr = "";
                num = 0;
            } else if (c == ']') {
                string prevStr = strSt.top(); strSt.pop();
                int repeat = numSt.top(); numSt.pop();
                for (int i = 0; i < repeat; i++) {
                    prevStr += curStr;
                }
                curStr = prevStr;
            } else {
                curStr += c;
            }
        }
        return curStr;
    }
};
```

#### 150.逆波兰表达式求值

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for (string& token : tokens) {
            if (token == "+" || token == "-" || token == "*" || token == "/") {
                int b = st.top(); st.pop();
                int a = st.top(); st.pop();
                if (token == "+") st.push(a + b);
                else if (token == "-") st.push(a - b);
                else if (token == "*") st.push(a * b);
                else st.push(a / b);
            } else {
                st.push(stoi(token));
            }
        }
        return st.top();
    }
};
```



---

## 九、字符串

### Easy

#### 14.最长公共前缀

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if (strs.empty()) return "";
        string prefix = strs[0];
        for (int i = 1; i < strs.size(); i++) {
            while (strs[i].find(prefix) != 0) {
                prefix = prefix.substr(0, prefix.size() - 1);
                if (prefix.empty()) return "";
            }
        }
        return prefix;
    }
};
```

#### 125.验证回文串

```c++
class Solution {
public:
    bool isPalindrome(string s) {
        int left = 0, right = s.size() - 1;
        while (left < right) {
            while (left < right && !isalnum(s[left])) left++;
            while (left < right && !isalnum(s[right])) right--;
            if (tolower(s[left++]) != tolower(s[right--])) return false;
        }
        return true;
    }
};
```

#### 28.找出字符串中第一个匹配项的下标

```c++
class Solution {
public:
    int strStr(string haystack, string needle) {
        int m = haystack.size(), n = needle.size();
        if (n == 0) return 0;
        for (int i = 0; i <= m - n; i++) {
            int j = 0;
            while (j < n && haystack[i + j] == needle[j]) j++;
            if (j == n) return i;
        }
        return -1;
    }
};
```

#### 58.最后一个单词的长度

```c++
class Solution {
public:
    int lengthOfLastWord(string s) {
        int ans = 0;
        for (int i = s.size() - 1; i >= 0; i--) {
            if (s[i] != ' ') ans++;
            else if (ans > 0) break;
        }
        return ans;
    }
};
```

### Medium

#### 49.字母异位词分组

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 哈希表：键为排序后的字符串（异位词统一标识），值为同组原始字符串列表
        unordered_map<string, vector<string>> groups;
        for (string& s : strs) {
            string key = s;
            sort(key.begin(), key.end());
            groups[key].push_back(s);
        }
        // 遍历哈希表，将所有分组结果收集至答案
        vector<vector<string>> ans;
        for (auto& [k, v] : groups) ans.push_back(v);
        return ans;
    }
};
```

#### 3.无重复字符的最长子串

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> seen;
        int left = 0, ans = 0;
        for (int right = 0; right < s.size(); right++) {
            while (seen.count(s[right])) {
                seen.erase(s[left++]);
            }
            seen.insert(s[right]);
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

#### 415.字符串相加

```c++
class Solution {
public:
    string addStrings(string num1, string num2) {
        int i = num1.size() - 1, j = num2.size() - 1;
        string ans;
        int carry = 0;
        while (i >= 0 || j >= 0 || carry) {
            int sum = carry;
            if (i >= 0) sum += num1[i--] - '0';
            if (j >= 0) sum += num2[j--] - '0';
            ans.push_back(sum % 10 + '0');
            carry = sum / 10;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

#### 43.字符串相乘

```c++
class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0") return "0";
        int m = num1.size(), n = num2.size();
        vector<int> pos(m + n);
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                int mul = (num1[i] - '0') * (num2[j] - '0');
                int sum = mul + pos[i + j + 1];
                pos[i + j + 1] = sum % 10;
                pos[i + j] += sum / 10;
            }
        }
        string ans;
        for (int i = 0; i < pos.size(); i++) {
            if (i == 0 && pos[i] == 0) continue;
            ans.push_back(pos[i] + '0');
        }
        return ans;
    }
};
```

---

## 十、贪心算法

### Easy

#### 455.分发饼干

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        ranges::sort(g);
        ranges::sort(s);
        int i = 0, j = 0;
        while (i < g.size() && j < s.size()) {
            if (s[j] >= g[i]) i++;
            j++;
        }
        return i;
    }
};
```

#### 605.种花问题

```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int count = 0;
        for (int i = 0; i < flowerbed.size(); i++) {
            if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) 
                && (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {
                flowerbed[i] = 1;
                count++;
            }
        }
        return count >= n;
    }
};
```

### Medium

#### 55.跳跃游戏

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int maxReach = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (i > maxReach) return false;
            maxReach = max(maxReach, i + nums[i]);
        }
        return true;
    }
};
```

#### 45.跳跃游戏II

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int ans = 0, curEnd = 0, nextEnd = 0;
        for (int i = 0; i < nums.size() - 1; i++) {
            nextEnd = max(nextEnd, i + nums[i]);
            if (i == curEnd) {
                ans++;
                curEnd = nextEnd;
            }
        }
        return ans;
    }
};
```

#### 763.划分字母区间

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int last[26] = {};
        for (int i = 0; i < s.size(); i++) {
            last[s[i] - 'a'] = i;
        }
        vector<int> ans;
        int start = 0, end = 0;
        for (int i = 0; i < s.size(); i++) {
            end = max(end, last[s[i] - 'a']);
            if (i == end) {
                ans.push_back(end - start + 1);
                start = i + 1;
            }
        }
        return ans;
    }
};
```

#### 134.加油站

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int total = 0, cur = 0, start = 0;
        for (int i = 0; i < gas.size(); i++) {
            total += gas[i] - cost[i];
            cur += gas[i] - cost[i];
            if (cur < 0) {
                start = i + 1;
                cur = 0;
            }
        }
        return total >= 0 ? start : -1;
    }
};
```

---

## 十一、排序与查找

### Easy

#### 704.二分查找

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }
};
```

#### 278.第一个错误的版本

```c++
class Solution {
public:
    int firstBadVersion(int n) {
        int left = 1, right = n;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (isBadVersion(mid)) right = mid;
            else left = mid + 1;
        }
        return left;
    }
};
```

#### 744.寻找比目标字母大的最小字母

```c++
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        int n = letters.size();
        int left = 0;
        int right = n;
        while (left < right) {
            // 计算中间位置
            auto mid = left + (right - left) / 2;
            if (letters[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return letters[left % n];
    }
};
```

#### 2529.正整数和负整数的最大计数

```c++
class Solution {
public:
    int maximumCount(vector<int>& nums) {
        int n = nums.size();
        int firstNonNeg = firstGreaterEqual(nums, 0);
        int firstPos = firstGreaterThan(nums, 0);
        int negativeCount = firstNonNeg;
        int positiveCount = n - firstPos;
        return max(negativeCount, positiveCount);
    }

private:
    // 二分查找：返回第一个 >= target 的索引
    int firstGreaterEqual(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }

    // 二分查找：返回第一个 > target 的索引
    int firstGreaterThan(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
};
```

#### 1385.两个数组间的距离值

```c++
class Solution {
public:
    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
        // 对两个数组升序排序
        ranges::sort(arr1);
        ranges::sort(arr2);
        int m = arr1.size();
        int n = arr2.size();
        int right = 0;
        int ans = 0;
        // 遍历排序后的 arr1 每个元素
        for (int left = 0; left < m; left++) {
            while (right < n && arr1[left] - arr2[right] > d) {
                right++;
            }
            if (right == n || arr2[right] - arr1[left] > d) {
                ans++;
            }
        }
        return ans;
    }
};
```

### Medium

#### 1283.使结果不超过阈值的最小除数

```c++
class Solution {
public:
    int smallestDivisor(vector<int>& nums, int threshold) {
        // 检查除数 m 是否满足条件
        auto check = [&](int m) -> bool {
            int sum = 0;
            for (int x : nums) {
                sum += (x + m - 1) / m;
                if (sum > threshold) {
                    return false;
                }
            }
            return true;
        };
        // 初始化二分查找边界并进行二分查找
        int left = 0;
        int right = ranges::max(nums);
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            if (check(mid)) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

#### 2187.完成旅途的最少时间

```c++
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        // 检查在 currentTime 时间内能否完成至少 totalTrips 趟行程
        auto check = [&](long long currentTime) -> bool {
            long long total = 0;
            for (auto t : time) {
                total += currentTime / t;
                if (total >= totalTrips) {
                    return true;
                }
            }
            return false;
        };
        // 初始化二分查找边界
        long long left = 0;
        int minTime = ranges::min(time);
        long long right = 1LL * minTime * totalTrips;
        // 寻找满足条件的最小时间
        while (right - left > 1) {
            auto mid = left + (right - left) / 2;
            if (check(mid)) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

#### 1011.在D天内送达包裹的能力

```c++
class Solution {
public:
    int shipWithinDays(vector<int>& weights, int days) {
        // 给定运载能力 cap，能否在 days 天内运完所有包裹
        auto check = [&](int cap) -> bool {
            int current = 0;
            int useDays = 1;
            for (int w : weights) {
                if (current + w > cap) {
                    useDays++;
                    current = w;
                    if (useDays > days) {
                        return false;
                    }
                } else {
                    current += w;
                }
            }
            return true;
        };
        int left = ranges::max(weights);
        int right = accumulate(weights.begin(), weights.end(), 0);
        // 寻找最小运载能力
        while (right - left > 0) {
            int mid = left + (right - left) / 2;
            if (check(mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

#### 275.H指数II

```c++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        // 找最大的 h，使得有 h 篇论文至少被引用 h 次
        // 即 citations[n-h] >= h
        auto check = [&](int h) -> bool {
            return citations[n - h] >= h;
        };
        int left = 0, right = n + 1;  // 开区间 (left, right)
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            if (check(mid)) {
                left = mid;  // mid 满足，尝试更大的
            } else {
                right = mid;  // mid 不满足，只能更小的
            }
        }
        return left;
    }
};
```

#### 2226.每个小孩最多能分到多少糖果

```c++
class Solution {
public:
    int maximumCandies(vector<int>& candies, long long k) {
        // 检查糖果是否够分
        auto check=[&](int num)->bool{
            long long sum=0;
            for(auto c:candies){
                sum+=c/num;
            }
            return sum>=k;
        };
        // 计算理论最大值
        long long average=reduce(candies.begin(),candies.end(),0LL)/k;
        int left=0;
        int right=min((long long)ranges::max(candies),average)+1;
        // 二分查找
        while(right-left>1){
            int mid=left+(right-left)/2;
            if(check(mid)){
                left=mid;
            }else{
                right=mid;
            }
        }
        return left;
    }
};
```

#### 2389.和有限的最长子序列

```c++
class Solution {
public:
    vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {
        // 要子序列和 ≤ query 且长度最长 → 选最小的若干个数
        ranges::sort(nums);
        partial_sum(nums.begin(), nums.end(), nums.begin());
        for (auto& cur : queries) {
            cur = ranges::upper_bound(nums, cur) - nums.begin();
        }
        return queries;
    }
};
```

#### 1170.比较字符串最小字母出现频次

```c++
class Solution {
private:
    int calcF(const string& s) {
        // 找到最小字符
        char minChar = *min_element(s.begin(), s.end());
        return count(s.begin(), s.end(), minChar);
    }

public:
    vector<int> numSmallerByFrequency(vector<string>& queries,
                                      vector<string>& words) {
        // 预处理 words
        vector<int> wordFreqs;
        wordFreqs.reserve(words.size());
        for (const string& word : words) {
            wordFreqs.push_back(calcF(word));
        }
        // 升序排序
        sort(wordFreqs.begin(), wordFreqs.end());
        vector<int> ans;
        ans.reserve(queries.size());
        for (const string& q : queries) {
            int fQuery = calcF(q);
            //    二分查找
            auto it = upper_bound(wordFreqs.begin(), wordFreqs.end(), fQuery);
            ans.push_back(wordFreqs.end() - it);
        }
        return ans;
    }
};
```

#### 215.数组中的第K个最大元素

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        nth_element(nums.begin(), nums.begin() + k - 1, nums.end(), greater<int>());
        return nums[k - 1];
    }
};
```

#### 347.前K个高频元素

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> count;
        for (int num : nums) count[num]++;
        vector<pair<int, int>> arr;
        for (auto& [num, freq] : count) arr.push_back({freq, num});
        nth_element(arr.begin(), arr.begin() + k, arr.end(), greater<pair<int, int>>());
        vector<int> ans;
        for (int i = 0; i < k; i++) ans.push_back(arr[i].second);
        return ans;
    }
};
```

#### 148.排序链表

```c++
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (!head || !head->next) return head;
        ListNode *slow = head, *fast = head->next;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        ListNode* mid = slow->next;
        slow->next = nullptr;
        return merge(sortList(head), sortList(mid));
    }
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);
        ListNode* cur = &dummy;
        while (l1 && l2) {
            if (l1->val < l2->val) { cur->next = l1; l1 = l1->next; }
            else { cur->next = l2; l2 = l2->next; }
            cur = cur->next;
        }
        cur->next = l1 ? l1 : l2;
        return dummy.next;
    }
};
```

---

## 十二、哈希表

### Easy

#### 1.两数之和

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        unordered_map<int, int> hash;
        // 找补数输出
        for (int i = 0; i < n; i++) {
            int complement = target - nums[i];
            if (hash.count(complement)) {
                return {hash[complement], i};
            }
            hash[nums[i]] = i;
        }
        return {};
    }
};
```

#### 217.存在重复元素

```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> seen;
        for (int num : nums) {
            if (seen.count(num)) return true;
            seen.insert(num);
        }
        return false;
    }
};
```

#### 242.有效的字母异位词

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size()) return false;
        int count[26] = {};
        for (char c : s) count[c - 'a']++;
        for (char c : t) {
            if (--count[c - 'a'] < 0) return false;
        }
        return true;
    }
};
```

### Medium

#### 128.最长连续序列

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int ans = 0;
        // 构建哈希集合
        unordered_set<int> hash(nums.begin(), nums.end());
        // 遍历每个唯一元素，尝试作为连续序列的起点
        for (auto left : hash) {
            if (hash.contains(left - 1)) {
                continue;
            }
            int right = left + 1;
            while (hash.contains(right)) {
                right++;
            }
            ans = max(ans, right - left);
        }
        return ans;
    }
};
```

#### 560.和为K的子数组

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> prefix;
        prefix[0] = 1;
        int sum = 0, ans = 0;
        for (int num : nums) {
            sum += num;
            ans += prefix[sum - k];
            prefix[sum]++;
        }
        return ans;
    }
};
```

---

## 十三、堆与优先队列

### Medium

#### 347.前K个高频元素

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> count;
        for (int num : nums) count[num]++;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        for (auto& [num, freq] : count) {
            pq.push({freq, num});
            if (pq.size() > k) pq.pop();
        }
        vector<int> ans;
        while (!pq.empty()) {
            ans.push_back(pq.top().second);
            pq.pop();
        }
        return ans;
    }
};
```

### Hard

#### 295.数据流的中位数

```c++
class MedianFinder {
    priority_queue<int> maxHeap; // 存较小的一半
    priority_queue<int, vector<int>, greater<>> minHeap; // 存较大的一半
public:
    MedianFinder() {}
    
    void addNum(int num) {
        if (maxHeap.empty() || num <= maxHeap.top()) {
            maxHeap.push(num);
        } else {
            minHeap.push(num);
        }
        // 平衡两个堆
        if (maxHeap.size() > minHeap.size() + 1) {
            minHeap.push(maxHeap.top()); maxHeap.pop();
        } else if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top()); minHeap.pop();
        }
    }
    
    double findMedian() {
        if (maxHeap.size() > minHeap.size()) return maxHeap.top();
        return (maxHeap.top() + minHeap.top()) / 2.0;
    }
};
```

#### 23.合并K个升序链表

```c++
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);
        for (ListNode* head : lists) {
            if (head) pq.push(head);
        }
        ListNode dummy(0);
        ListNode* cur = &dummy;
        while (!pq.empty()) {
            ListNode* node = pq.top(); pq.pop();
            cur->next = node;
            cur = cur->next;
            if (node->next) pq.push(node->next);
        }
        return dummy.next;
    }
};
```

---

## 十四、位运算

### Easy

#### 136.只出现一次的数字

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int num : nums) ans ^= num;
        return ans;
    }
};
```

#### 191.位1的个数

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        while (n) {
            n &= n - 1;
            count++;
        }
        return count;
    }
};
```

### Medium

#### 137.只出现一次的数字II

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ones = 0, twos = 0;
        for (int num : nums) {
            ones = (ones ^ num) & ~twos;
            twos = (twos ^ num) & ~ones;
        }
        return ones;
    }
};
```

#### 260.只出现一次的数字III

```c++
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int xorAll = 0;
        for (int num : nums) xorAll ^= num;
        int diffBit = xorAll & (-xorAll);
        int a = 0, b = 0;
        for (int num : nums) {
            if (num & diffBit) a ^= num;
            else b ^= num;
        }
        return {a, b};
    }
};
```