# 算法笔记

## 数组

### Easy

#### 88.合并两个有序数组

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // 从后往前比较和填充，避免覆盖nums1中的有效元素
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        // 从后往前比较和填充
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k] = nums1[i];
                i--;
            } else {
                nums1[k] = nums2[j];
                j--;
            }
            k--;
        }
        // 剩余元素复制到nums1
        while (j >= 0) {
            nums1[k] = nums2[j];
            j--;
            k--;
        }
    }
};
```

#### 121.买卖股票的最佳时机

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        int minPrice = prices[0];
        int cur = prices[0];
        int n = prices.size();
        // 更新最大利润ans和最低价格minPrice
        for (int i = 0; i < n; i++) {
            cur = prices[i];
            ans = max(ans, cur - minPrice);
            minPrice = min(minPrice, cur);
        }
        return ans;
    }
};
```

#### 283.移动零

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int write = 0;
        // 原地覆盖非零元素
        for (int read = 0; read < n; read++) {
            if (nums[read] != 0) {
                nums[write] = nums[read];
                write++;
            }
        }
        // 原地将剩余位置置为0
        while (write < n) {
            nums[write] = 0;
            write++;
        }
    }
};
```

#### 1013.将数组分成和相等的三个部分

```c++
class Solution {
public:
    bool canThreePartsEqualSum(vector<int>& arr) {
        int total = accumulate(arr.begin(), arr.end(), 0);
        if (total % 3 != 0) {
            return false;
        }
        int target = total / 3;
        int findCount = 0;
        int curSum = 0;
        for (auto cur : arr) {
            curSum += cur;
            if (curSum == target) {
                findCount++;
                // 重置，开始下一段
                curSum = 0;
            }
        }
        return findCount >= 3;
    }
};
```

### Medium

#### 15.三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        ranges::sort(nums);
        int n = nums.size();
        vector<vector<int>> ans;
        for (int i = 0; i < n - 2; i++) {
            int x = nums[i];
            // 去重 a
            if (i > 0 && x == nums[i - 1]) {
                continue;
            }
            // 提前退出：如果最小值都大于0，后面不可能有解
            if (x > 0) {
                break;
            }
            // 剪枝：最小的三个数之和大于0
            if (x + nums[i + 1] + nums[i + 2] > 0) {
                break;
            }
            // 剪枝：当前 a 加上最大的两个数小于0
            if (x + nums[n - 2] + nums[n - 1] < 0) {
                continue;
            }
            int j = i + 1;
            int k = n - 1;
            while (j < k) {
                long long sum = static_cast<long long>(x) + nums[j] + nums[k];
                if (sum < 0) {
                    j++;
                } else if (sum > 0) {
                    k--;
                } else {
                    ans.push_back({x, nums[j], nums[k]});
                    // 去重
                    j++;
                    while (j < k && nums[j] == nums[j - 1]) {
                        j++;
                    }
                    k--;
                    while (j < k && nums[k] == nums[k + 1]) {
                        k--;
                    }
                }
            }
        }
        return ans;
    }
};
```

#### 53.最大子数组和

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 卡丹算法
        int ans = nums[0];
        int currentSum = nums[0];
        int n = nums.size();
        for (int i = 1; i < n; i++) {
            currentSum = max(nums[i], currentSum + nums[i]);
            ans = max(ans, currentSum);
        }
        return ans;
    }
};
```

#### 55.跳跃游戏

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        // 记录当前能够到达的最远下标
        int maxDistance=0;
        for (int i = 0; i < n; i++) {
            // 当前下标已经超出范围返回false
            if (i > maxDistance) {
                return false;
            }
            maxDistance = max(maxDistance, i + nums[i]);
        }
        return true;
    }
};
```

#### 189.轮转数组

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        // 计算有效旋转步数
        k %= nums.size();
        // 三步反转实现轮转
        ranges::reverse(nums);
        reverse(nums.begin(), nums.begin() + k);
        reverse(nums.begin() + k, nums.end());
    }
};
```

#### 75.颜色分类

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n=nums.size();
        int red=0;
        int white=0;
        int blue=0;
        for(auto num:nums){
            if(num==0){
                red++;
            }else if(num==1){
                white++;
            }else{
                blue++;
            }
        }
        for(int i=0;i<n;i++){
            if(i>=0&&i<red){
                nums[i]=0;
            }else if(i>=red+white){
                nums[i]=2;
            }else{
                nums[i]=1;
            }
        }
    }
};
```

#### 26.删除有序数组中的重复项

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        // 双指针法，如果vector长度为0则返回
        int n = nums.size();
        if (!n) {
            return 0;
        }
        int slow = 1;
        int fast = 1;
        // 如果fast指针遇到前后数字不相等则数字不重复，赋值给slow指针即可
        while (fast < n) {
            if (nums[fast] != nums[fast - 1]) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

#### 380.O(1)时间插入、删除和获取随机元素

```c++
class RandomizedSet {
private:
    std::vector<int> nums;
    std::unordered_map<int, int> indices;

public:
    // 初始化随机数种子
    RandomizedSet() { srand((unsigned)time(NULL)); }
    // 插入元素
    bool insert(int val) {
        if (indices.count(val)) {
            return false;
        }
        int index = nums.size();
        nums.emplace_back(val);
        indices[val] = index;
        return true;
    }
    // 移除元素
    bool remove(int val) {
        if (!indices.count(val)) {
            return false;
        }
        int index = indices[val];
        int last = nums.back();
        // 用最后一个元素覆盖待删除元素
        nums[index] = last;
        indices[last] = index;
        nums.pop_back();
        indices.erase(val);
        return true;
    }
    // 生成随机索引
    int getRandom() {
        int randomIndex = rand() % nums.size();
        return nums[randomIndex];
    }
};
```

---

## 链表

### Easy

#### 21.合并两个有序链表

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 加一个dummy节点避免处理头节点
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;
        // 双指针遍历两个链表，每次将较小的节点接到合并链表末尾
        while (list1 && list2) {
            if (list1->val <= list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        // 拼接剩余链表，并返回头节点
        cur->next = list1 ? list1 : list2;
        return dummy->next;
    }
};
```

#### 160.相交链表

```c++
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode* p1=headA;
        ListNode* p2=headB;
        // 双指针法，不相遇则遍历
        while(p1!=p2){
            if(p1==nullptr){
                p1=headB;
            }else{
                p1=p1->next;
            }
            if(p2==nullptr){
                p2=headA;
            }else{
                p2=p2->next;
            }
        }
        return p1;
    }
};
```

#### 206.反转链表

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre=nullptr;
        // cur指向当前正在处理的节点
        ListNode *cur=head;
        // 遍历整个链表
        while(cur){
            ListNode *next=cur->next;
            cur->next=pre;
            pre=cur;
            cur=next;
        }
        return pre;
    }
};
```

#### 141.环形链表

```c++
class Solution {
public:
    bool hasCycle(ListNode* head) {
        // 快慢指针，相遇成环
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
};
```

### Medium

#### 142.环形链表II

```c++
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        struct ListNode* slow = head;
        struct ListNode* fast = head;
        // 快慢指针，如果2个指针相遇后慢指针还要走一个a的距离到入环口
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                while (slow != head) {
                    slow = slow->next;
                    head = head->next;
                }
                return slow;
            }
        }
        return NULL;
    }
};
```

#### 19.删除链表的倒数第N个结点

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 快慢指针
        ListNode dummy = {0, head};
        ListNode* left = &dummy;
        ListNode* right = &dummy;
        for (int i = 1; i <= n; i++) {
            right = right->next;
        }
        // 右指针到倒数第二个节点
        while (right->next) {
            left = left->next;
            right = right->next;
        }
        // 跳过左指针的下一个节点即可
        ListNode* nxt = left->next;
        left->next = left->next->next;
        delete nxt;
        return dummy.next;
    }
};
```

#### 2.两数相加

```c++
// 初始化答案为一个「空链表」，每次循环，向该链表末尾添加一个节点（保存一个数位）
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 构造哨兵节点
        ListNode dummy;
        ListNode* current = &dummy;
        int carry = 0;
        // 每个结点保存一个数位
        while (l1 || l2 || carry) {
            if (l1) {
                carry += l1->val;
                l1 = l1->next;
            }
            if (l2) {
                carry += l2->val;
                l2 = l2->next;
            }
            ListNode* newNode = new ListNode(carry % 10);
            current->next = newNode;
            current = newNode;
            carry /= 10;
        }
        return dummy.next;
    }
};
```

#### 24.两两交换链表中的节点

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // 创建哨兵节点
        ListNode dummy{0, head};
        ListNode* node0 = &dummy;
        ListNode* node1 = head;
        while (node1 && node1->next) {
            // 定义临时指针
            ListNode* node2 = node1->next;
            ListNode* node3 = node2->next;
            // 交换2个节点
            node0->next = node2;
            node2->next = node1;
            // 链表下一个指针指向下一个需要交换的节点
            node1->next = node3;
            // 更新指针
            node0 = node1;
            node1 = node3;
        }
        return dummy.next;
    }
};
```

#### 25.K个一组翻转链表

```c++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // 计算节点数
        int nodeNum = 0;
        for (ListNode* current = head; current != NULL;
             current = current->next) {
            nodeNum++;
        }
        ListNode dummy{0,head};
        ListNode *p0=&dummy;
        ListNode *pre=nullptr;
        ListNode *current=head;
        for(int i=nodeNum;i>=k;i-=k){
            // k个结点为一组进行翻转
            for(int i=0;i<k;i++){
                ListNode *nxt=current->next;
                current->next=pre;
                pre=current;
                current=nxt;
            }
            // 将当前节点移动到下一组翻转的节点的头节点
            ListNode *nxt=p0->next;
            p0->next->next=current;
            p0->next=pre;
            p0=nxt;
        }
        return dummy.next;
    }
};
```

#### 138.随机链表的复制

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        // 先判断空节点的情况
        if (!head) {
            return nullptr;
        }
        // 遍历复制每个节点，吧新节点插到老节点后面
        for (Node* cur = head; cur; cur = cur->next->next) {
            Node* newNode = new Node(cur->val, cur->next, nullptr);
            cur->next = newNode;
        }
        // 设置新节点的random指针
        for (Node* cur = head; cur; cur = cur->next->next) {
            // 如果原节点的 random 指针不为空，新节点的 random 指针指向原节点的
            // random 指针的下一个节点
            if (cur->random) {
                cur->next->random = cur->random->next;
            }
        }
        // 双链表分离
        Node* newHead = head->next;
        Node* current = head;
        while (current->next->next) {
            Node* copy = current->next;
            current->next = copy->next;
            copy->next = copy->next->next;
            current = current->next;
        }
        // 处理最后一个节点
        current->next = nullptr;
        return newHead;
    }
};
```

#### 146.LRU缓存

```c++
class Node {
public:
    int key;
    int value;
    Node* prev;
    Node* next;
    Node(int k = 0, int v = 0) : key(k), value(v) {}
};

class LRUCache {
private:
    int capacity;
    Node* dummy;
    unordered_map<int, Node*> key_to_node;

    // 删除一个节点
    void remove(Node* x) {
        x->prev->next = x->next;
        x->next->prev = x->prev;
    }

    // 在链表头添加一个节点
    void push_front(Node* x) {
        x->prev = dummy;
        x->next = dummy->next;
        x->prev->next = x;
        x->next->prev = x;
    }

    // 获取 key 对应的节点，同时把该节点移到链表头部
    Node* get_node(int key) {
        auto it = key_to_node.find(key);
        if (it == key_to_node.end()) {
            return nullptr;
        }
        Node* node = it->second;
        remove(node);
        push_front(node);
        return node;
    }

public:
    LRUCache(int capacity) : capacity(capacity), dummy(new Node()) {
        dummy->prev = dummy;
        dummy->next = dummy;
    }

    int get(int key) {
        Node* node = get_node(key);
        return node ? node->value : -1;
    }

    void put(int key, int value) {
        // get_node 会把对应节点移到链表头部
        Node* node = get_node(key);
        if (node) {
            node->value = value;
            return;
        }
        key_to_node[key] = node = new Node(key, value);
        push_front(node);
        if (key_to_node.size() > capacity) {
            Node* back_node = dummy->prev;
            key_to_node.erase(back_node->key);
            remove(back_node);
            delete back_node;
        }
    }
};
```

---

## 动态规划

### Easy

#### 70.爬楼梯

```c++
// 解法1
class Solution {
public:
    int climbStairs(int n) {
        // 记忆化数组
        vector<int> memory(n + 1, 0);
        auto dfs = [&](this auto&& self, int i) -> int {
            // 递归终止
            if (i <= 1) {
                return 1;
            }
            // 已计算则直接返回
            int& ret = memory[i];
            if (ret) {
                return ret;
            }
            return ret = self(i - 1) + self(i - 2);
        };
        return dfs(n);
    }
};
// 解法2
class Solution {
    vector<int> memory;
    // 记忆化
    int dfs(int i) {
        if (i <= 1) {
            return 1;
        }
        // 检查是否已计算过当前结果
        int& ret = memory[i];
        if (ret) {
            return ret;
        }
        // 递归：爬到第 i 阶 = 爬到第 i-1 阶 + 爬到第 i-2 阶
        return ret = dfs(i - 2) + dfs(i - 1);
    }

public:
    int climbStairs(int n) {
        memory.resize(n + 1);
        return dfs(n);
    }
};
```

### Medium

#### 198.打家劫舍

```c++
// 记忆化搜索解法
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        // 记忆化数组存储子数组结果
        vector<int> memo(n, -1);
        auto dfs = [&](this auto&& dfs, int i) -> int {
            // 无房屋可抢劫，返回0
            if (i < 0) {
                return 0;
            }
            // 抢劫过的房屋直接返回结果
            if (memo[i] != -1) {
                return memo[i];
            }
            // 计算最大抢劫金额
            return memo[i] = max(dfs(i - 1), dfs(i - 2) + nums[i]);
        };
        // 反向遍历房屋
        return dfs(n - 1);
    }
};
// 状态压缩解法
class Solution {
public:
    int rob(vector<int>& nums) {
        int f0 = 0;
        int f1 = 0;
        // 遍历每个房屋的金额
        for (auto x : nums) {
            // 计算最大收益
            int new_f = max(f1, f0 + x);
            // 更新状态
            f0 = f1;
            f1 = new_f;
        }
        // 返回最大收益
        return f1;
    }
};
```

#### 322.零钱兑换

```c++
// 记忆化搜索解法
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        // 记忆化数组并初始化
        vector memo(n, vector<int>(amount + 1, -1));
        auto dfs = [&](this auto&& dfs, int coinNum, int remainCoin) -> int {
            // 硬币用尽
            if (coinNum < 0) {
                return remainCoin == 0 ? 0 : INT_MAX / 2;
            }
            // 当前硬币面值大于剩余金额：无法使用该硬币
            int& res = memo[coinNum][remainCoin];
            if (res != -1) {
                return res;
            }
            // 核心决策
            if (remainCoin < coins[coinNum]) {
                return res = dfs(coinNum - 1, remainCoin);
            }
            return res = min(dfs(coinNum - 1, remainCoin),
                             dfs(coinNum, remainCoin - coins[coinNum]) + 1);
        };
        int ans = dfs(n - 1, amount);
        return ans < INT_MAX / 2 ? ans : -1;
    }
};
// 完全背包解法
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dpTable(amount + 1, INT_MAX / 2);
        dpTable[0] = 0;
        for (auto coin : coins) {
            // 从当前硬币面值开始，更新到目标金额的状态
            for (int cur = coin; cur <= amount; cur++) {
                // 是否使用当前硬币可减少硬币数量
                dpTable[cur] = min(dpTable[cur], dpTable[cur - coin] + 1);
            }
        }
        int minCoins = dpTable[amount];
        return minCoins < INT_MAX / 2 ? minCoins : -1;
    }
};
```

#### 1143.最长公共子序列

```c++
// 记忆化搜索解法
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        vector memo(m, vector<int>(n, -1));
        // 递归搜索 + 保存计算结果 = 记忆化搜索
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0 || j < 0) {
                return 0;
            }
            int& ret = memo[i][j];
            if (ret != -1) {
                return ret;
            }
            if (text1[i] == text2[j]) {
                return ret = dfs(i - 1, j - 1) + 1;
            }
            return ret = max(dfs(i - 1, j), dfs(i, j - 1));
        };
        return dfs(m - 1, n - 1);
    }
};
// 线性DP解法
class Solution {
public:
    int longestCommonSubsequence(string s, string t) {
        int m = t.size();
        vector<int> dp(m + 1, 0);
        for (auto cur : s) {
            int pre = dp[0];
            for (int j = 0; j < m; j++) {
                int tmp = dp[j + 1];
                // 字符匹配时取左上角值+1，否则取上方或左方最大值
                if (cur == t[j]) {
                    dp[j + 1] = pre + 1;
                } else {
                    dp[j + 1] = max(dp[j + 1], dp[j]);
                }
                // 更新pre
                pre = tmp;
            }
        }
        return dp[m];
    }
};
```

#### 72.编辑距离

```c++
// 记忆化搜索解法
class Solution {
public:
    int minDistance(string word1, string word2) {
        // 递归搜索 + 保存计算结果 = 记忆化搜索
        int m = word1.size();
        int n = word2.size();
        vector memo(m, vector<int>(n, -1));
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0) {
                return j + 1;
            }
            if (j < 0) {
                return i + 1;
            }
            int& ret = memo[i][j];
            if (ret != -1) {
                return ret;
            }
            if (word1[i] == word2[j]) {
                return ret = dfs(i - 1, j - 1);
            }
            return ret = min({dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1)}) + 1;
        };
        return dfs(m - 1, n - 1);
    }
};
// 线性DP解法
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word2.size();
        vector<int> dp(m + 1, 0);
        // 初始化
        for (int j = 0; j < m; j++) {
            dp[j + 1] = j + 1;
        }
        for (auto cur : word1) {
            int pre = dp[0];
            dp[0]++;
            for (int j = 0; j < m; j++) {
                int tmp = dp[j + 1];
                if (cur == word2[j]) {
                    dp[j + 1] = pre;
                } else {
                    dp[j + 1] = min({dp[j + 1], dp[j], pre}) + 1;
                }
                pre = tmp;
            }
        }
        return dp[m];
    }
};
```

#### 120.三角形最小路径和

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        // 存储动态规划过程中的状态
        auto f = triangle[n - 1];
        // 由顶到底的最短路径取决于它下方相邻的两个位置
        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                f[j] = min(f[j], f[j + 1]) + triangle[i][j];
            }
        }
        return f[0];
    }
};
```

---

## 哈希表

### Easy

#### 1.两数之和

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        unordered_map<int, int> hash;
        // 使用哈希表来存储已经遍历过的数字及其索引
        for (int i = 0; i < n; i++) {
            auto current = nums[i];
            // 查找 target - current 是否在哈希表中
            auto it = hash.find(target - current);
            if (it != hash.end()) {
                return {it->second, i};
            }
            hash[current] = i;
        }
        return {};
    }
};
```

### Medium

#### 49.字母异位词分组

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> map;
        // 遍历输入字符串并分组
        for (auto s : strs) {
            string sort_s = s;
            sort(sort_s.begin(), sort_s.end());
            map[sort_s].push_back(s);
        }
        // 哈希表转换为结果
        vector<vector<string>> result;
        result.reserve(map.size());
        for (auto cur : map) {
            result.push_back(cur.second);
        }
        return result;
    }
};
```

#### 128.最长连续序列

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int ans = 0;
        // 哈希集合初始化并去重
        unordered_set<int> hash(nums.begin(), nums.end());
        for (int left : hash) {
            // 寻找序列起点
            if (hash.contains(left - 1)) {
                continue;
            }
            // 寻找序列终点
            int right = left + 1;
            while (hash.contains(right)) {
                right++;
            }
            ans = max(ans, right - left);
        }
        // 输出答案
        return ans;
    }
};
```

---

## 二分查找

### Easy

#### 35.搜索插入位置

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int length = nums.size();
        int left = 0;
        int right = length - 1;
        // 二分查找模板题
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

#### 69.X的平方根

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0 || x == 1)
            return x;
        int left = 1;
        int right = min(x, 46340);
        int ans = 0;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // 用除法替代乘法
            if (mid <= x / mid) {
                ans = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return ans;
    }
};
```

#### 704.二分查找

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // 和之前的模板有点不同，要在循环中找到结果就直接输出
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
};
```

### Medium

#### 33.搜索旋转排序数组

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int end = nums.back();
        // 构建虚拟数组check
        auto check = [&](int i) -> bool {
            int x = nums[i];
            if (x > end) {
                return target > end && x >= target;
            }
            return target > end || x >= target;
        };
        // 进行二分查找
        int left = -1;
        int right = nums.size() - 1;
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            if(check(mid)){
                right=mid;
            }else{
                left=mid;
            }
        }
        return nums[right] == target ? right : -1;
    }
};
```

#### 34.在排序数组中查找元素的第一个和最后一个位置

```c++
class Solution {
private:
    int lower_bound(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        // 这里需要加=是因为要找到第一个大于等于target的位置
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }

public:
    vector<int> searchRange(vector<int>& nums, int target) {
        // 查找target的起始位置
        int start = lower_bound(nums, target);
        if (start == nums.size() || nums[start] != target) {
            return {-1, -1};
        }
        // 查找target+1的起始位置，减1得到target的结束位
        int end = lower_bound(nums, target + 1) - 1;
        // 返回找到的起始和结束位置
        return {start, end};
    }
};
```

#### 74.搜索二维矩阵

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        int left = -1;
        int right = m * n;
        // 把矩阵从左上到右下排成一个大数组，进行二分查找即可
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            int cur = matrix[mid / n][mid % n];
            if (cur == target) {
                return true;
            }
            if (cur < target) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return false;
    }
};
```

#### 153.寻找旋转排序数组中的最小值

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = -1;
        int right = nums.size() - 1;
        // 和最后一个数比大小，进行二分查找
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < nums.back()) {
                right = mid;
            } else
                left = mid;
        }
        return nums[right];
    }
};
```

#### 162.寻找峰值

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = -1;
        int right = nums.size() - 1;
        while (left + 1 < right) {
            auto mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

#### 875.爱吃香蕉的阿珂

```c++
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        auto check = [&](int k) -> bool {
            int sum = piles.size();
            for (auto p : piles) {
                // 计算当前堆能否吃完，吃不完返回FALSE
                sum += (p - 1) / k;
                if (sum > h) {
                    return false;
                }
            }
            return true;
        };
        int left = 0;
        int right = ranges::max(piles);
        // 二分查找
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            if (check(mid)) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

---

## 滑动窗口

### Medium

#### 3.无重复字符的最长子串

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int left = 0;
        int ans = 0;
        unordered_map<int, int> hash;
        // 使用哈希表，如果有某个元素的频率超过1就缩小窗口
        for (int right = 0; right < n; right++) {
            auto cur = s[right];
            hash[cur]++;
            while (hash[cur] > 1) {
                hash[s[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

#### 76.最小覆盖子串

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        // 初始化最小窗口边界
        int ans_left = -1;
        int ans_right = s.length();
        int hash[128]{};
        int debt = 0;
        // 遍历字符串并初始化哈希表
        for (auto cur : t) {
            if (hash[cur] == 0) {
                debt++;
            }
            hash[cur]++;
        }
        // 初始化滑动窗口左指针
        int left = 0;
        for (int right = 0; right < s.length(); right++) {
            char c = s[right];
            hash[c]--;
            if (hash[c] == 0) {
                debt--;
            }
            // 满足覆盖条件下缩小窗口
            while (debt == 0) {
                if (right - left < ans_right - ans_left) {
                    ans_left = left;
                    ans_right = right;
                }
                char current = s[left];
                if (hash[current] == 0) {
                    debt++;
                }
                hash[current]++;
                left++;
            }
        }
        return (ans_left < 0) ? ""
                              : s.substr(ans_left, ans_right - ans_left + 1);
    }
};
```

#### 209.长度最小的子数组

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int ans = n + 1;
        int left = 0;
        int currentNum = 0;
        for (int right = 0; right < n; right++) {
            currentNum += nums[right];
            // 如果当前窗口和大于target直接缩窗即可，更新ans
            while (currentNum >= target) {
                ans = min(ans, right - left + 1);
                currentNum -= nums[left];
                left++;
            }
        }
        return (ans <= n) ? ans : 0;
    }
};
```

#### 239.滑动窗口最大值

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> ans; 
        deque<int> q;    
        for (int i = 0; i < nums.size(); i++) {
            // 维护队列单调性：从队尾移除比当前元素小的索引
            while (!q.empty() && nums[q.back()] <= nums[i]) {
                q.pop_back();
            }
            q.push_back(i);
            // 移除超出窗口范围的队首元素
            if (!q.empty() && q.front() <= i - k) {
                q.pop_front();
            }
            // 记录当前窗口最大值
            if (i >= k - 1) {
                ans.push_back(nums[q.front()]);
            }
        }
        return ans;
    }
};
```

#### 424.替换后的最长重复字符

```c++
class Solution {
public:
    int characterReplacement(string s, int k) {
        int n = s.size();
        int ans = 0;
        int left = 0;
        // 统计窗口内各字符出现次数
        vector<int> cnt(26);
        for (int right = 0; right < n; right++) {
            cnt[s[right] - 'A']++;
            // 当前窗口中最 frequent 字符的数量
            int maxCnt = ranges::max(cnt);
            // 需要替换的字符数 = 窗口大小 - 最 frequent 字符数
            while (right - left + 1 - maxCnt > k) {
                cnt[s[left] - 'A']--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

---

## 双指针

### Easy

#### 125.验证回文串

```c++
class Solution {
public:
    bool isPalindrome(string s) {
        int left = 0;
        int n = s.size();
        int right = n - 1;
        // 相向双指针解法
        while (left <= right) {
            if (!isalnum(s[left])) {
                left++;
            } else if (!isalnum(s[right])) {
                right--;
            } else if (tolower(s[left]) == tolower(s[right])) {
                left++;
                right--;
            } else {
                return false;
            }
        }
        return true;
    }
};
```

#### 283.移动零

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int left = 0;
        for (int right = 0; right < n; right++) {
            // 遇到非0的值直接交换
            if (nums[right]) {
                swap(nums[left], nums[right]);
                left++;
            }
        }
    }
};
```

### Medium

#### 11.盛最多水的容器

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        int ans = 0;
        int left = 0;
        int right = n - 1;
        while (left < right) {
            // 计算面积，左右挡板谁矮谁移动，搜最大值
            auto area = (right - left) * min(height[left], height[right]);
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
            ans = max(ans, area);
        }
        return ans;
    }
};
```

#### 15.三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        // 预处理排序
        ranges::sort(nums);
        int n = nums.size();
        vector<vector<int>> ans;
        // 遍历数组，固定第一个数x
        for (int i = 0; i <= n - 3; i++) {
            auto x = nums[i];
            // 剪枝优化
            if (i != 0 && x == nums[i - 1]) {
                continue;
            }
            if (x + nums[i + 1] + nums[i + 2] > 0) {
                break;
            }
            if (x + nums[n - 2] + nums[n - 1] < 0) {
                continue;
            }
            // 双指针法：j从i+1开始，k从末尾开始
            auto j = i + 1;
            auto k = n - 1;
            while (j < k) {
                auto sum = x + nums[j] + nums[k];
                if (sum > 0) {
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    ans.push_back({x, nums[j], nums[k]});
                    // 剪枝优化
                    for (j++; j < k && nums[j] == nums[j - 1]; j++) {
                        continue;
                    }
                    for (k--; j < k && nums[k] == nums[k + 1]; k--) {
                        continue;
                    }
                }
            }
        }
        return ans;
    }
};
```

#### 42.接雨水

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int ret = 0;
        int prefix = 0;
        int suffix = 0;
        // 相向双指针，谁小谁移动，同时计算雨水量即可
        while (left < right) {
            prefix = fmax(prefix, height[left]);
            suffix = fmax(suffix, height[right]);
            if (height[left] < height[right]) {
                ret += prefix - height[left];
                left++;
            } else {
                ret += suffix - height[right];
                right--;
            }
        }
        return ret;
    }
};
```

#### 167.两数之和II-输入有序数组

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        // 双指针解题，根据题目数组元素非递减解即可
        int length = numbers.size();
        int left = 0;
        int right = length - 1;
        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (sum == target) {
                return {left + 1, right + 1};
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
        return {-1, -1};
    }
};
```

---

## 二叉树

### Easy

#### 94.二叉树的中序遍历

```c++
class Solution {
    void traversal(TreeNode* cur, vector<int>& vec) {
        // 递归终止条件：当前节点为空
        if (!cur) {
            return;
        }
        // 递归遍历左子树,访问当前节点，递归遍历右子树
        traversal(cur->left, vec);
        vec.push_back(cur->val);
        traversal(cur->right, vec);
    }

public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        // 从根节点开始递归遍历
        traversal(root, ans);
        return ans;
    }
};
```

#### 100.相同的树

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 当前节点如果为空，左右子树必须都是nullptr
        if (q == nullptr || p == nullptr) {
            return q == p;
        }
        // 遍历左右子树
        return q->val == p->val && isSameTree(p->left, q->left) &&
               isSameTree(p->right, q->right);
    }
};
```

#### 101.对称二叉树

```c++
class Solution {
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 处理有空指针的情况
        if (!p || !q) {
            return p == q;
        }
        // 二叉树对称需要值相等且左右子树镜像对称
        return p->val == q->val && isSameTree(p->right, q->left) &&
               isSameTree(p->left, q->right);
    }

public:
    bool isSymmetric(TreeNode* root) {
        return isSameTree(root->left, root->right);
    }
};
```

#### 104.二叉树的最大深度

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        // 递归寻找左右子树的深度，找一个最大值然后+1即可
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        return max(leftDepth, rightDepth) + 1;
    }
};
```

### Medium

#### 102.二叉树的层序遍历

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        // 若根节点为空，直接返回空二维数组
        if (!root) {
            return {};
        }
        vector<vector<int>> ans;
        queue<TreeNode*> q;
        q.push(root);
        // 循环处理直到队列为空
        while (!q.empty()) {
            vector<int> vals;
            // 保存当前层节点数
            for (int n = q.size(); n > 0; n--) {
                auto node = q.front();
                q.pop();
                vals.push_back(node->val);
                // 将非空子节点加入队列
                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
            // 存入结果
            ans.emplace_back(vals);
        }
        return ans;
    }
};
```

#### 103.二叉树的锯齿形层序遍历

```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        if (!root) {
            return {};
        }
        vector<vector<int>> ans;
        vector<TreeNode*> cur = {root};
        bool leftToRight = true;
        while (!cur.empty()) {
            vector<TreeNode*> nxt;
            vector<int> vals;
            vals.reserve(cur.size());
            // 遍历当前层节点
            for (auto node : cur) {
                // 从左往右就尾插，否则头插
                if (leftToRight) {
                    vals.push_back(node->val);
                } else {
                    vals.insert(vals.begin(), node->val);
                }
                // 子节点入队
                if (node->left) {
                    nxt.push_back(node->left);
                }
                if (node->right) {
                    nxt.push_back(node->right);
                }
            }
            cur = move(nxt);            
            ans.push_back(move(vals));  
            leftToRight = !leftToRight; 
        }
        return ans;
    }
};
```

#### 105.从前序与中序遍历序列构造二叉树

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (preorder.empty()) {
            return nullptr;
        }
        // 确定根节点
        int left_size = ranges::find(inorder, preorder[0]) - inorder.begin();
        // 构建左子树的前序遍历 中序遍历
        vector<int> pre1(preorder.begin() + 1,
                         preorder.begin() + 1 + left_size);
        vector<int> in1(inorder.begin(), inorder.begin() + left_size);
        // 构建右子树的前序遍历 中序遍历
        vector<int> pre2(preorder.begin() + 1 + left_size, preorder.end());
        vector<int> in2(inorder.begin() + 1 + left_size, inorder.end());
        TreeNode* left = buildTree(pre1, in1);
        TreeNode* right = buildTree(pre2, in2);
        return new TreeNode(preorder[0], left, right);
    }
};
```

#### 114.二叉树展开为链表

```c++
class Solution {
    TreeNode* head;

public:
    void flatten(TreeNode* root) {
        // 处理入参空指针情况
        if (root == nullptr) {
            return;
        }
        // 遍历右子树，左子树
        flatten(root->right);
        flatten(root->left);
        // 使用头插法
        root->left = nullptr;
        root->right = head;
        head = root;
    }
};
```

#### 236.二叉树的最近公共祖先

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 若当前节点为空或等于p/q，直接返回当前节点
        if (!root || root == p || root == q) {
            return root;
        }
        // 递归搜索左右子树
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        // 左右子树均找到目标节点,返回当前节点
        if (left && right) {
            return root;
        }
        // 看左子树是否为空，为空则递归右子树
        return left ? left : right;
    }
};
```

---

## 回溯

### Medium

#### 17.电话号码的字母组合

```c++
class Solution {
    // 构建映射表
    const string MAPPING[10] = {"",    "",    "abc",  "def", "ghi",
                                "jkl", "mno", "pqrs", "tuv", "wxyz"};

public:
    vector<string> letterCombinations(string digits) {
        // 获取字符串长度
        int n = digits.size();
        // 处理空字符串的情况
        if (n == 0) {
            return {};
        }
        vector<string> ans;
        string path(n, 0);
        auto dfs = [&](this auto&& dfs, int i) -> void {
            // 处理完所有数字添加结果
            if (i == n) {
                ans.emplace_back(path);
                return;
            }
            // 遍历数字对应的字母
            for (auto& c : MAPPING[digits[i] - '0']) {
                path[i] = c;
                dfs(i + 1);
            }
        };
        // 开始深度优先搜索
        dfs(0);
        return ans;
    }
};
```

#### 46.全排列

```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> ans;
        vector<int> path(n);
        vector<int> on_path(n);
        auto dfs = [&](this auto&& dfs, int i) {
            // 已生成完整排列则保存
            if (i == n) {
                ans.emplace_back(path);
                return;
            }
            // 遍历所有数字
            for (int j = 0; j < n; j++) {
                // 若元素未使用
                if (!on_path[j]) {
                    // 选择数字
                    path[i] = nums[j];
                    on_path[j] = true;
                    // 填充下一个位置
                    dfs(i + 1);
                    // 回溯
                    on_path[j] = false;
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```

#### 78.子集

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> ans;
        vector<int> path;
        auto dfs = [&](this auto&& dfs, int i) -> void {
            // 递归终止,将当前路径加入结果集
            if (i == n) {
                ans.emplace_back(path);
                return;
            }
            // 不选，直接递归下一层
            dfs(i + 1);
            // 选，选择当前数字
            path.push_back(nums[i]);
            dfs(i + 1);
            path.pop_back();
        };
        dfs(0);
        return ans;
    }
};
```

#### 39.组合总和

```c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> path;
        function<void(int, int)> dfs = [&](int i, int left) {
            if (left == 0) {
                // 找到一个合法组合
                ans.push_back(path);
                return;
            }
            if (i == candidates.size() || left < 0) {
                return;
            }
            // 不选
            dfs(i + 1, left);
            // 选
            path.push_back(candidates[i]);
            dfs(i, left - candidates[i]);
            path.pop_back();
        };
        dfs(0, target);
        return ans;
    }
};
```

### Hard

#### 51.N皇后

```c++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;
        vector board(n, string(n, '.'));
        vector<uint8_t> col(n, false);
        vector<uint8_t> diag1(n * 2 - 1, false);
        vector<uint8_t> diag2(n * 2 - 1, false);
        auto dfs = [&](this auto&& dfs, int r) {
            // 所有行都已放置皇后
            if (r == n) {
                ans.push_back(board);
                return;
            }
            // 放置皇后
            for (int c = 0; c < n; c++) {
                // 计算两条对角线的索引
                int diag1_idx = r + c;
                int diag2_idx = r - c + n - 1;
                // 检查当前位置是否安全
                if (!col[c] && !diag1[diag1_idx] && !diag2[diag2_idx]) {
                    // 放置皇后,标记并回溯
                    board[r][c] = 'Q';
                    col[c] = diag1[diag1_idx] = diag2[diag2_idx] = true;
                    dfs(r + 1);
                    col[c] = diag1[diag1_idx] = diag2[diag2_idx] = false;
                    board[r][c] = '.';
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```

---

## 图论

### Medium

#### 200.岛屿数量

```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int ans = 0;
        int m = grid.size();
        int n = grid[0].size();
        // 标记陆地的深度优先搜索
        auto dfs = [&](this auto&& dfs, int i, int j) -> void {
            // 边界检查
            if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') {
                return;
            }
            // 插旗避免来回横跳，递归搜索
            grid[i][j] = '2';
            dfs(i, j - 1);
            dfs(i, j + 1);
            dfs(i - 1, j);
            dfs(i + 1, j);
        };
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 发现新岛屿则标记所有陆地
                if (grid[i][j] == '1') {
                    dfs(i, j);
                    ans++;
                }
            }
        }
        return ans;
    }
};
```

#### 207.课程表

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 构建邻接表，表示每个课程的前置课程
        vector<vector<int>> g(numCourses);
        for (auto& p : prerequisites) {
            g[p[1]].push_back(p[0]);
        }
        vector<int> colors(numCourses, 0);
        // 定义一个递归的 DFS 函数，返回 true 表示找到了环
        auto dfs = [&](this auto&& dfs, int i) -> bool {
            colors[i] = 1; // 标记 i 正在访问中
            for (int y : g[i]) {
                if (colors[y] == 1 || (colors[y] == 0 && dfs(y))) {
                    return true;
                }
            }
            colors[i] = 2;
            return false;
        };
        // 遍历所有课程，检查是否存在环
        for (int i = 0; i < numCourses; i++) {
            if (colors[i] == 0 && dfs(i)) {
                return false;
            }
        }
        return true;
    }
};
```

---

## 栈

### Easy

#### 20.有效的括号

```c++
class Solution {
public:
    bool isValid(string s) {
        // 字符串长度为奇数直接false
        if (s.size() % 2) {
            return false;
        }
        // 遍历字符串
        stack<char> st;
        for (auto cur : s) {
            if (cur == '(') {
                st.push(')');
            } else if (cur == '[') {
                st.push(']');
            } else if (cur == '{') {
                st.push('}');
            } else {
                // 没有左括号，或者左括号类型不对,返回false
                if (st.empty() || st.top() != cur) {
                    return false;
                }
                // 出栈
                st.pop();
            }
        }
        return st.empty();
    }
};
```

#### 155.最小栈

```c++
class MinStack {
    stack<pair<int, int>> st;

public:
    // 使用栈存储元素
    MinStack() { st.emplace(0, INT_MAX); }
    // 弹栈
    void push(int val) { st.emplace(val, min(getMin(), val)); }
    // 入栈
    void pop() { st.pop(); }
    // 弹出栈顶
    int top() { return st.top().first; }
    // 使用栈存储元素
    int getMin() { return st.top().second; }
};
```

### Medium

#### 739.每日温度

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // 主要是用单调栈的解法解题
        int n = temperatures.size();
        vector<int> ans(n, 0);
        stack<int> st;
        for (int i = n - 1; i >= 0; i--) {
            int currentTemperature = temperatures[i];
            // 弹出所有温度 <= 当前温度的栈顶元素
            while (!st.empty() &&
                   currentTemperature >= temperatures[st.top()]) {
                st.pop();
            }
            // 搜索栈顶元素
            if (!st.empty()) {
                ans[i] = st.top() - i;
            }
            st.push(i);
        }
        return ans;
    }
};
```

#### 84.柱状图中最大的矩形

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        heights.push_back(-1);
        stack<int> st;
        st.push(-1);
        int ans = 0;
        // 遍历基地
        for (int right = 0; right < heights.size(); right++) {
            while (st.size() > 1 && heights[right] <= heights[st.top()]) {
                // 计算矩形面积
                int i = st.top();
                st.pop();
                int left = st.top();
                ans = max(ans, heights[i] * (right - left - 1));
            }
            st.push(right);
        }
        return ans;
    }
};
```

---

## 字符串

### Easy

#### 14.最长公共前缀

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        // 处理字符串为空的情况
        if (strs.empty()) {
            return " ";
        }
        // 以第一个字符串为基准字符串遍历即可
        string& baseStr = strs[0];
        for (int j = 0; j < baseStr.size(); j++) {
            for (string& s : strs) {
                if (j == s.size() || s[j] != baseStr[j]) {
                    return baseStr.substr(0, j);
                }
            }
        }
        return baseStr;
    }
};
```

### Medium

#### 415.字符串相加

```c++
class Solution {
public:
    string addStrings(string num1, string num2) {
        // 获取字符串长度并初始化指针
        int m = num1.size();
        int n = num2.size();
        int i = m - 1;
        int j = n - 1;
        int add = 0;
        string ans;
        // 预分配空间
        ans.reserve(max(m, n) + 1);
        while (i >= 0 || j >= 0 || add) {
            int x = (i >= 0) ? num1[i--] - '0' : 0;
            int y = (j >= 0) ? num2[j--] - '0' : 0;
            // 计算当前位总和
            int sum = x + y + add;
            ans.push_back('0' + sum % 10);
            add = sum / 10;
        }
        // 将逆序结果反转后返回
        return string(ans.rbegin(), ans.rend());
    }
};
```

---

## 贪心

### Easy

#### 121.买卖股票的最佳时机

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int ans = 0;
        int minPrice = prices[0];
        for (int i = 1; i < n; i++) {
            auto cur = prices[i];
            ans = max(ans, cur - minPrice);
            minPrice = min(minPrice, cur);
        }
        return ans;
    }
};
```

### Medium

#### 55.跳跃游戏

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int maxDistance = 0;
        // 遍历数组，维护最右可达位置，某次达不到就返回false
        for (int i = 0; i < nums.size(); i++) {
            if (i > maxDistance) {
                return false;
            }
            maxDistance = max(maxDistance, i + nums[i]);
        }
        return true;
    }
};
```

#### 45.跳跃游戏II

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int ans = 0;
        int current_right = 0;
        int next_right = 0;
        // 寻找最远可以跳到的地方
        for (int i = 0; i < nums.size() - 1; i++) {
            next_right = max(next_right, i + nums[i]);
            // 建桥寻找方案
            if (i == current_right) {
                current_right = next_right;
                ans++;
            }
        }
        // 输出结果
        return ans;
    }
};
```

---

## 矩阵

### Medium

#### 48.旋转图像

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // 转置
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < i; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        // 后翻转
        for (auto& row : matrix) {
            ranges::reverse(row);
        }
    }
};
```

#### 54.螺旋矩阵

```c++
class Solution {
    static constexpr int DIRS[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int> ans(m * n);
        int i = 0;
        int j = 0;
        int di = 0;
        for (int k = 0; k < m * n; k++) {
            // 标记当前位置已访问
            ans[k] = matrix[i][j];
            // 计算按当前方向的下一个位置
            matrix[i][j] = INT_MAX;
            int x = i + DIRS[di][0];
            int y = j + DIRS[di][1];
            // 检查是否需要改变方向（越界或已访问）
            if (x < 0 || y < 0 || x >= m || y >= n || matrix[x][y] == INT_MAX) {
                di = (di + 1) % 4;
            }
            // 移动到下一个位置
            i += DIRS[di][0];
            j += DIRS[di][1];
        }
        return ans;
    }
};
```

#### 240.搜索二维矩阵II

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m=matrix.size();
        int n=matrix[0].size();
        int i=0;
        int j=n-1;
        while(i<m&&j>=0){
            // 如果右上角元素为target直接输出
            if(matrix[i][j]==target){
                return true;
            }else if(matrix[i][j]<target){
                // 本行所有数小于target，搜下一行
                i++;
            }else if(matrix[i][j]>target){
                // 本列所有数大于target，搜下一列
                j--;
            }
        }
        return false;
    }
};
```

---

## 排序

### Medium

#### 56.合并区间

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // 按区间起始点排序
        ranges::sort(intervals);
        vector<vector<int>> ans;
        for (auto& current : intervals) {
            // 当前区间与结果中最后一个区间重叠
            if (!ans.empty() && current[0] <= ans.back()[1]) {
                ans.back()[1] = max(ans.back()[1], current[1]);
            } else {
                // 当前区间无重叠
                ans.emplace_back(current);
            }
        }
        return ans;
    }
};
```

#### 215.数组中的第K个最大元素

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        // 排序取倒数第K大的元素即可
        ranges::sort(nums);
        int ret = nums[n - k];
        return ret;
    }
};
```

---

## 位运算

### Easy

#### 136.只出现一次的数字

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        // 遍历数组中的每个元素,只出现一次的数字会保留
        for (auto num : nums) {
            ans ^= num;
        }
        return ans;
    }
};
```

### Medium

#### 43.字符串相乘

```c++
class Solution {
public:
    string multiply(string num1, string num2) {
        // 边界处理
        if (num1 == "0" || num2 == "0") {
            return "0";
        }
        int m = num1.size();
        int n = num2.size();
        vector<int> ansArr(m + n, 0);
        // 逐位相乘并累加
        for (int i = m - 1; i >= 0; i--) {
            int x = num1[i] - '0';
            if (x == 0) {
                continue;
            }
            for (int j = n - 1; j >= 0; j--) {
                int y = num2[j] - '0';
                if (y == 0) {
                    continue;
                }
                ansArr[i + j + 1] += x * y;
            }
        }
        // 统一进位
        int carry = 0;
        for (int i = m + n - 1; i >= 0; i--) {
            int sum = ansArr[i] + carry;
            carry = sum / 10;
            ansArr[i] = sum % 10;
        }
        // 转换为字符串
        string ans;
        int start = 0;
        if (ansArr[0] == 0) {
            start = 1;
        }
        for (int i = start; i < m + n; i++) {
            ans += (ansArr[i] + '0');
        }
        return ans;
    }
};
```

---

## 堆

### Hard

#### 295.数据流的中位数

```c++
class MedianFinder {
    // 最大堆，最小堆
    priority_queue<int> left;
    priority_queue<int, vector<int>, greater<>> right;

public:
    // 添加数字并动态平衡最大最小两个堆
    void addNum(int num) {
        if (left.size() == right.size()) {
            // 两堆大小相等时：添加后需使left堆大小+1
            right.push(num);
            left.push(right.top());
            right.pop();
        } else {
            left.push(num);
            right.push(left.top());
            left.pop();
        }
    }
    // 查找当前中位数
    double findMedian() {
        if (left.size() > right.size()) {
            return left.top();
        }
        return (left.top() + right.top()) / 2.0;
    }
};
```

---

## 前缀和

### Medium

#### 238.除自身以外数组的乘积

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        // 计算前缀乘积
        vector<int> prefix(n, 1);
        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] * nums[i - 1];
        }
        // 计算后缀乘积
        vector<int> suffix(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            suffix[i] = suffix[i + 1] * nums[i + 1];
        }
        // 计算前后缀乘积作为答案输出
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            ans[i] = prefix[i] * suffix[i];
        }
        return ans;
    }
};
```

---

## 字典树

### Medium

#### 208.实现Trie(前缀树)

```c++
struct Node {
    Node* son[26]{};
    bool end = false;
};
class Trie {
    Node* root = new Node();
    int find(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) {
                return 0;
            }
            cur = cur->son[c];
        }
        // 走过同样的路（2=完全匹配，1=前缀匹配）
        return cur->end ? 2 : 1;
    }

public:
    void insert(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) { // 无路可走？
                cur->son[c] = new Node(); // new 出来！
            }
            cur = cur->son[c];
        }
        cur->end = true;
    }
    bool search(string word) { return find(word) == 2; }
    bool startsWith(string prefix) { return find(prefix) != 0; }
};
```

---

## BFS

### Medium

#### 102.二叉树的层序遍历

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        // 若根节点为空，直接返回空二维数组
        if (root == nullptr) {
            return {};
        }
        vector<vector<int>> ans;
        queue<TreeNode*> q;
        q.push(root);
        // 循环处理直到队列为空
        while (!q.empty()) {
            vector<int> vals;
            // 保存当前层节点数
            for (int n = q.size(); n > 0; n--) {
                auto node = q.front();
                q.pop();
                vals.push_back(node->val);
                // 将非空子节点加入队列
                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
            // 存入结果
            ans.emplace_back(vals);
        }
        return ans;
    }
};
```

#### 513.找树左下角的值

```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        TreeNode* node;
        queue<TreeNode*> q;
        q.push(root);
        // 遍历所有节点
        while (!q.empty()) {
            node = q.front();
            q.pop();
            // 先右后左入队
            if (node->right) {
                q.push(node->right);
            }
            if (node->left) {
                q.push(node->left);
            }
        }
        // 返回目标节点的值
        return node->val;
    }
};
```


# 算法笔记 - 补充题目

## 数组（补充）

### Medium（补充）

#### 31.下一个排列

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        ranges::next_permutation(nums);
    }
};
```

#### 1535.找出数组游戏的赢家

```c++
class Solution {
public:
    int getWinner(vector<int>& arr, int k) {
        int maxNum = arr[0];
        int win = 0;
        // 遍历数组,如果出现当前最大值失败的情况就重置胜利次数
        for (int i = 1; i < arr.size() && win < k; i++) {
            if (arr[i] > maxNum) {
                maxNum = arr[i];
                win = 0;
            }
            win++;
        }
        return maxNum;
    }
};
```

#### 624.数组列表中的最大距离

```c++
class Solution {
public:
    int maxDistance(vector<vector<int>>& arrays) {
        int ans = 0;
        int miniNum = INT_MAX / 2;
        int maxNum = INT_MIN / 2;
        // 遍历每个数组
        for (auto& current : arrays) {
            // 更新答案
            ans = max({ans, current.back() - miniNum, maxNum - current[0]});
            miniNum = min(miniNum, current[0]);
            maxNum = max(maxNum, current.back());
        }
        return ans;
    }
};
```

#### 357.统计各位数字都不同的数字个数

```c++
class Solution {
public:
    int countNumbersWithUniqueDigits(int n) {
        if (n == 0) {
            return 1;
        }
        if (n == 1) {
            return 10;
        }
        // 初始化结果为 10
        int result = 10;
        // 当前位数的组合数
        int currentCombination = 9;
        for (int i = 0; i < n - 1; i++) {
            currentCombination *= (9 - i);
            result += currentCombination;
        }
        return result;
    }
};
```

#### 674.最长连续递增序列

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int ans = 0;        
        int n = nums.size(); 
        int start = 0;       
        for (int i = 0; i < n; i++) {
            // 重置
            if (i > 0 && nums[i] <= nums[i - 1]) {
                start = i;
            }
            // 更新全局最大值
            ans = max(ans, i - start + 1);
        }
        return ans;
    }
};
```

#### 135.分发糖果

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        if (n <= 1) {
            return n;
        }
        vector<int> candies(n, 1);
        // 正向遍历
        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i - 1]) {
                candies[i] = candies[i - 1] + 1;
            }
        }
        // 反向遍历
        int ans = candies[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) {
                candies[i] = max(candies[i], candies[i + 1] + 1);
            }
            ans += candies[i];
        }
        return ans;
    }
};
```

#### 228.汇总区间

```c++
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> ans;
        int i = 0;
        int n = nums.size();
        // 遍历整个数组
        while (i < n) {
            int low = i;
            i++;
            // 探测连续区间的终点
            while (i < n && nums[i] == nums[i - 1] + 1) {
                i++;
            }
            int high = i - 1;
            // 生成区间字符串
            string temp = to_string(nums[low]);
            if (low < high) {
                temp.append("->");
                temp.append(to_string(nums[high]));
            }
            ans.push_back(move(temp));
        }
        return ans;
    }
};
```

#### 334.递增的三元子序列

```c++
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int first = INT_MAX;
        int second = INT_MAX;
        for (auto num : nums) {
            if (num <= first) {
                // 更新最小值
                first = num;
            } else if (num <= second) {
                // 更新次小值
                second = num;
            } else {
                // 找到大于second的值
                return true;
            }
        }
        return false;
    }
};
```

#### 3487.删除后的最大子数组元素和

```c++
class Solution {
public:
    int maxSum(vector<int>& nums) {
        unordered_set<int> uniquePositives;
        int sum = 0;
        int maxNegative = INT_MIN;
        for (auto num : nums) {
            if (num < 0) {
                // 更新最大负数
                maxNegative = max(maxNegative, num);
            } else if (uniquePositives.insert(num).second) {
                sum += num;
            }
        }
        // 根据是否存在非负数返回结果
        return uniquePositives.empty() ? maxNegative : sum;
    }
};
```

---

## 链表（补充）

### Medium（补充）

#### 92.反转链表II

```c++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode dummy{0, head};
        ListNode* pre = &dummy;
        // 移动到反转区间
        for (int i = 1; i < left; i++) {
            pre = pre->next;
        }
        ListNode* cur = pre->next;
        // 对区间内节点进行反转
        for (int i = 0; i < right - left; i++) {
            ListNode* nxt = cur->next;
            cur->next = nxt->next;
            nxt->next = pre->next;
            pre->next = nxt;
        }
        return dummy.next;
    }
};
```

#### 234.回文链表

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> nums;
        // 遍历链表，将每个节点的值存入数组
        while (head) {
            nums.emplace_back(head->val);
            head = head->next;
        }
        int left = 0;
        int right = nums.size() - 1;
        // 如果左右指针指向的值不相等则不是回文链表
        while (left < right) {
            if (nums[left] != nums[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
};
```

#### 148.排序链表

```c++
class Solution {
    // 获取链表长度
    int getListLength(ListNode* head) {
        int length = 0;
        while (head) {
            length++;
            head = head->next;
        }
        return length;
    }

    // 分割链表
    ListNode* splitList(ListNode* head, int size) {
        // 先找到 next_head 的前一个节点
        ListNode* cur = head;
        for (int i = 0; i < size - 1 && cur; i++) {
            cur = cur->next;
        }
        // 如果链表长度异常返回空节点
        if (cur == nullptr || cur->next == nullptr) {
            return nullptr;
        }
        ListNode* next_head = cur->next;
        cur->next = nullptr;
        return next_head;
    }

    // 返回合并后的链表的头节点和尾节点
    pair<ListNode*, ListNode*> mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy;
        ListNode* cur = &dummy;
        while (list1 && list2) {
            if (list1->val < list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2;
        while (cur->next) {
            cur = cur->next;
        }
        return {dummy.next, cur};
    }

public:
    ListNode* sortList(ListNode* head) {
        int length = getListLength(head);
        ListNode dummy(0, head);
        // 遍历链表
        for (int step = 1; step < length; step *= 2) {
            ListNode* new_list_tail = &dummy;
            ListNode* cur = dummy.next;
            while (cur) {
                // 分割链表
                ListNode* head1 = cur;
                ListNode* head2 = splitList(head1, step);
                cur = splitList(head2, step);
                // 合并链表
                auto [head, tail] = mergeTwoLists(head1, head2);
                new_list_tail->next = head;
                new_list_tail = tail;
            }
        }
        return dummy.next;
    }
};
```

#### 23.合并K个升序链表

```c++
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // 优先队列按节点值大小排序
        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq;
        // 头节点存在加入优先队列
        for (auto head : lists) {
            if (head) {
                pq.push(head);
            }
        }
        // 定义虚拟节点
        ListNode dummy{};
        ListNode* cur = &dummy;
        // 从优先队列取最小节点构建结果链表
        while (!pq.empty()) {
            auto* node = pq.top();
            pq.pop();
            // 如果最小节点有下一个节点，将其加入优先队列
            if (node->next) {
                pq.push(node->next);
            }
            // 最小节点加入结果链表，并移动当前指针
            cur->next = node;
            cur = cur->next;
        }
        return dummy.next;
    }
};
```

#### 143.重排链表

```c++
class Solution {
    // 寻找中间节点
    ListNode* middleNode(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
    ListNode* revert(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while (cur) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }

public:
    void reorderList(ListNode* head) {
        // 找到中间节点后面部分开始翻转
        ListNode* mid = middleNode(head);
        ListNode* head2 = revert(mid);
        // 合并两个链表
        while (head2->next) {
            // 保存前后部分的下一个节点
            ListNode* nxt = head->next;
            ListNode* nxt2 = head2->next;
            // 将head2插入到head和nxt之间
            head->next = head2;
            head2->next = nxt;
            // 更新指针
            head = nxt;
            head2 = nxt2;
        }
    }
};
```

#### 876.链表的中间结点

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        // 快慢指针，快指针走2步，慢指针走1步，最后慢指针就是中间节点
        ListNode *fast=head;
        ListNode *slow=head;
        while(fast&&fast->next){
            fast=fast->next->next;
            slow=slow->next;
        }
        return slow;
    }
};
```

#### 2130.链表最大孪生和

```c++
class Solution {
public:
    int pairSum(ListNode* head) {
        // 快慢指针找到中间节点
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        // 反转链表
        ListNode* pre = nullptr;
        while (slow) {
            ListNode* nxt = slow->next;
            slow->next = pre;
            pre = slow;
            slow = nxt;
        }
        // 重新设置后半部分头节点找最大和
        ListNode* head1 = pre;
        int maxNum = -1;
        while (head1) {
            int sum = head->val + head1->val;
            maxNum = max(maxNum, sum);
            head = head->next;
            head1 = head1->next;
        }
        return maxNum;
    }
};
```

#### 237.删除链表中的节点

```c++
class Solution {
public:
    void deleteNode(ListNode* node) {
        *node=*node->next;
    }
};
```

#### 83.删除排序链表中的重复元素

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        // 处理异常情况
        if (head == nullptr) {
            return head;
        }
        ListNode* cur = head;
        // 如果一个节点和他下一个节点值相等就删除该节点
        while (cur->next) {
            if (cur->val == cur->next->val) {
                cur->next = cur->next->next;
            } else {
                cur = cur->next;
            }
        }
        return head;
    }
};
```

#### 82.删除排序链表中的重复元素II

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode dummy{0, head};
        ListNode* cur = &dummy;
        while (cur->next && cur->next->next) {
            auto nextVal = cur->next->val;
            // 后两个节点值相同,值等于 val 的节点全部删除
            if (nextVal == cur->next->next->val) {
                while (cur->next && cur->next->val == nextVal) {
                    cur->next = cur->next->next;
                }
            } else {
                // 移动到下一个节点
                cur = cur->next;
            }
        }
        return dummy.next;
    }
};
```

#### 203.移除链表元素

```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode dummy{0, head};
        ListNode* cur = &dummy;
        // 如果下一个节点的值为val删除该节点，否则继续向后遍历链表
        while (cur->next) {
            auto nxt = cur->next;
            if (val == nxt->val) {
                cur->next = nxt->next;
            } else {
                cur = nxt;
            }
        }
        return dummy.next;
    }
};
```

#### 3217.从链表中移除在数组中存在的节点

```c++
class Solution {
public:
    ListNode* modifiedList(vector<int>& nums, ListNode* head) {
        // 使用哈希表然后一次遍历即可
        unordered_set<int> hash(nums.begin(), nums.end());
        ListNode dummy{0, head};
        ListNode* cur = &dummy;
        while (cur->next) {
            ListNode* nxt = cur->next;
            if (hash.contains(nxt->val)) {
                cur->next = nxt->next;
            } else {
                cur = nxt;
            }
        }
        return dummy.next;
    }
};
```

#### 2487.从链表中移除节点

```c++
class Solution {
public:
    ListNode* removeNodes(ListNode* head) {
        // 本质上就是倒着遍历链表
        if (head->next == nullptr) {
            return head;
        }
        ListNode* nxt = removeNodes(head->next);
        if (nxt->val > head->val) {
            return nxt;
        } else {
            head->next = nxt;
            return head;
        }
    }
};
```

#### 445.两数相加II

```c++
class Solution {
    ListNode* reverseList(ListNode* head) {
        // 空链表或单节点直接返回
        if (!head || !head->next) {
            return head;
        }
        auto new_head = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return new_head;
    }

    // 递归相加两链表
    ListNode* addTwo(ListNode* l1, ListNode* l2, int carry = 0) {
        if (!l1 && !l2) {
            return carry ? new ListNode(carry) : nullptr;
        }
        if (!l1) {
            swap(l1, l2);
        }
        carry += l1->val + (l2 ? l2->val : 0);
        l1->val = carry % 10;
        l1->next = addTwo(l1->next, (l2 ? l2->next : nullptr), carry / 10);
        return l1;
    }

public:
    // 正序链表相加
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        l1 = reverseList(l1);
        l2 = reverseList(l2);
        auto l3 = addTwo(l1, l2);
        return reverseList(l3);
    }
};
```

#### 2816.翻倍以链表形式表示的数字

```c++
class Solution {
    // 反转链表
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = nullptr, *cur = head;
        while (cur) {
            auto nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }

    // 两数相加
    ListNode* double_(ListNode* l1) {
        ListNode dummy;
        auto cur = &dummy;
        int carry = 0;
        while (l1) {
            carry += l1->val * 2;
            cur->next = new ListNode(carry % 10);
            carry /= 10;
            cur = cur->next;
            l1 = l1->next;
        }
        // 处理最终进位
        if (carry) {
            cur->next = new ListNode(carry);
        }
        return dummy.next;
    }

public:
    // 链表整数加倍
    ListNode* doubleIt(ListNode* head) {
        head = reverseList(head);
        auto res = double_(head);
        return reverseList(res);
    }
};
```

#### 1669.合并两个链表

```c++
class Solution {
public:
    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {
        ListNode dummy{0, list1};
        ListNode* pre1 = &dummy;
        // 移动p到删除区间的前一个节点
        for (int i = 0; i < a; i++) {
            pre1 = pre1->next;
        }
        // 到达删除区间末尾
        ListNode* pre2 = pre1->next;
        for (int i = 0; i < b - a + 1; i++) {
            pre2 = pre2->next;
        }
        // 连接list2到删除区间前节点,找到尾节点，接上原链表
        pre1->next = list2;
        while (list2->next) {
            list2 = list2->next;
        }
        list2->next = pre2;
        return dummy.next;
    }
};
```



---

## 动态规划（补充）

### Medium（补充）

#### 494.目标和

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        // 计算数组总和
        int sum = reduce(nums.begin(), nums.end()) - abs(target);
        // 边界检查
        if (sum < 0 || sum % 2) {
            return 0;
        }
        int capacity = sum / 2;
        vector<int> dp(capacity + 1, 0);
        dp[0] = 1;
        for (auto num : nums) {
            // 倒序遍历背包容量
            for (int cur = capacity; cur >= num; cur--) {
                dp[cur] += dp[cur - num];
            }
        }
        return dp[capacity];
    }
};
```

#### 300.最长递增子序列

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // 贪心+二分解法
        auto end = nums.begin();
        for (auto cur : nums) {
            // 查找第一个 >= cur 的位置
            auto it = lower_bound(nums.begin(), end, cur);
            *it = cur;
            // 若插入位置是序列末尾，则扩展序列长度
            if (it == end) {
                end++;
            }
        }
        return end - nums.begin();
    }
};
```

#### 122.买卖股票的最佳时机II

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 状态机DP解法
        // 初始化当前现金和当前利润
        int cash = 0;
        int curProfit = INT_MIN;
        for (auto cur : prices) {
            // 更新现金，更新当前利润并同步状态
            int new_f = max(cash, curProfit + cur);
            curProfit = max(curProfit, cash - cur);
            cash = new_f;
        }
        return cash;
    }
};
```

#### 309.买卖股票的最佳时机含冷冻期

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int preMaxProfit = 0;
        int cash = 0;
        int curProfit = INT_MIN;
        for (auto cur : prices) {
            // 更新现金和当前利润状态
            int newCash = max(cash, curProfit + cur);
            curProfit = max(curProfit, preMaxProfit - cur);
            // 滚动更新状态，与不带冷冻期比多更新一个2天前利润
            preMaxProfit = cash;
            cash = newCash;
        }
        return cash;
    }
};
```

#### 188.买卖股票的最佳时机IV

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        // 状态机DP解法
        vector<array<int, 2>> f(k + 2, {INT_MIN / 2, INT_MIN / 2});
        for (int j = 1; j <= k + 1; j++) {
            f[j][0] = 0;
        }
        for (auto cur : prices) {
            for (int j = k + 1; j > 0; j--) {
                // 更新不持有股票的状态
                f[j][0] = max(f[j][0], f[j][1] + cur);
                // 更新持有股票的状态
                f[j][1] = max(f[j][1], f[j - 1][0] - cur);
            }
        }
        return f[k + 1][0];
    }
};
```

#### 516.最长回文子序列

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        // 区间DP解法
        int n = s.size();
        vector<int> dp(n, 1);
        for (int i = n - 1; i >= 0; i--) {
            int pre = 0;
            for (int j = i + 1; j < n; j++) {
                int tmp = dp[j];
                // 状态转移：两端相等则+2，否则继承左右子串最大值
                if (s[i] == s[j]) {
                    dp[j] = pre + 2;
                } else {
                    dp[j] = max(dp[j], dp[j - 1]);
                }
                // 更新pre为下一轮准备
                pre = tmp;
            }
        }
        return dp[n - 1];
    }
};
```

#### 1039.多边形三角剖分的最低得分

```c++
class Solution {
public:
    int minScoreTriangulation(vector<int>& values) {
        int n = values.size();
        vector<vector<int>> f(n, vector<int>(n, 0));
        // 逆序遍历起点
        for (int i = n - 3; i >= 0; i--) {
            for (int j = i + 2; j < n; j++) {
                f[i][j] = INT_MAX;
                for (int k = i + 1; k < j; k++) {
                    // 状态转移方程
                    f[i][j] =
                        min(f[i][j], f[i][k] + f[k][j] +
                                         values[i] * values[j] * values[k]);
                }
            }
        }
        return f[0][n - 1];
    }
};
```

#### 118.杨辉三角

```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> c(numRows);
        for (int i = 0; i < numRows; i++) {
            c[i].resize(i + 1, 1);
            // 遍历第i行的元素
            for (int j = 1; j < i; j++) {
                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
            }
        }
        return c;
    }
};
```

#### 279.完全平方数

```c++
class Solution {
public:
    int numSquares(int n) {
        // 创建一个大小为n+1的数组f，用于存储每个数i的最小平方数之和
        vector<int> f(n + 1);
        // 遍历数字
        for (int i = 1; i <= n; i++) {
            int minNum = INT_MAX;
            for (int j = 1; j * j <= i; j++) {
                minNum = min(minNum, f[i - j * j]);
            }
            // f[i]的值为找到的最小值加1
            f[i] = minNum + 1;
        }
        return f[n];
    }
};
```

#### 139.单词拆分

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        // 计算字典中最长单词的长度
        int max_len = ranges::max(wordDict, {}, &string::length).length();
        // 将单词字典转换为哈希集合，用于快速查找
        unordered_set<string> words(wordDict.begin(), wordDict.end());
        int n = s.size();
        vector<int> f(n + 1);
        f[0] = true;
        // 遍历字符串的每个位置
        for (int i = 1; i <= n; i++) {
            for (int j = i - 1; j >= max(i - max_len, 0); j--) {
                if (f[j] && words.count(s.substr(j, i - j))) {
                    f[i] = true;
                    break;
                }
            }
        }
        return f[n];
    }
};
```

#### 152.乘积最大子数组

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        vector<int> fmax(n), fmin(n);
        fmax[0] = nums[0];
        fmin[0] = nums[0];
        // 遍历 nums 的同时，维护子数组的最大/小乘积，最后输出
        for (int i = 1; i < n; i++) {
            auto x = nums[i];
            fmax[i] = max({fmax[i - 1] * x, fmin[i - 1] * x, x});
            fmin[i] = min({fmax[i - 1] * x, fmin[i - 1] * x, x});
        }
        return ranges::max(fmax);
    }
};
```

### Hard（补充）

#### 5.最长回文子串

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        // 在字符串的开头和结尾分别添加特殊字符 '^' 和 '$'，并在每个字符之间插入 '#'，构造一个新的字符串 t
        string t = "^";
        for (char c : s) {
            t += '#';
            t += c;
        }
        t += "#$";
        // 存储每个位置的回文半径
        vector<int> half_len(t.length() - 2);
        half_len[1] = 1;
        int box_m = 0, box_r = 0, max_i = 0;
        // 遍历新的字符串 t，从第二个位置开始
        for (int i = 2; i < half_len.size(); i++) {
            int hl = 1;
            if (i < box_r) {
                hl = min(half_len[box_m * 2 - i], box_r - i);
            }
            while (t[i - hl] == t[i + hl]) {
                hl++;
                box_m = i;
                box_r = i + hl;
            }

            half_len[i] = hl;
            if (hl > half_len[max_i]) {
                max_i = i;
            }
        }
        // 计算最长回文子串的起始位置和长度，并返回结果
        int hl = half_len[max_i];
        return s.substr((max_i - hl) / 2, hl - 1);
    }
};
```

#### 32.最长有效括号

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int left = 0;
        int right = 0;
        int maxlength = 0;
        // 从左到右遍历字符串
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                left++;
            } else {
                right++;
            }
            // 左右括号数相等则更新有效括号长度一次
            if (left == right) {
                maxlength = max(maxlength, 2 * right);
            } else if (right > left) {
                left = 0;
                right = 0;
            }
        }
        left = 0;
        right = 0;
        // 从右到左遍历字符串
        for (int i = (int)s.length() - 1; i >= 0; i--) {
            if (s[i] == '(') {
                left++;
            } else {
                right++;
            }
            // 左右括号数相等则更新有效括号长度一次
            if (left == right) {
                maxlength = max(maxlength, 2 * left);
            } else if (left > right) {
                left = 0;
                right = 0;
            }
        }
        return maxlength;
    }
};
```

#### 416.分割等和子集

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int s = reduce(nums.begin(), nums.end());
        // 排除元素总和为奇数
        if (s % 2) {
            return false;
        }
        int n = nums.size();
        vector<vector<int>> memo(n, vector<int>(s / 2 + 1, -1));
        // 深度优先搜索
        auto dfs = [&](this auto&& dfs, int i, int j) -> bool {
            if (i < 0) {
                return j == 0;
            }
            // 获取当前状态的引用,如果当前状态已经计算过，直接返回结果
            int& res = memo[i][j];
            if (res != -1) {
                return res;
            }
            // 计算当前状态的结果
            return res = (j >= nums[i] && dfs(i - 1, j - nums[i])) ||
                         dfs(i - 1, j);
        };
        return dfs(n - 1, s / 2);
    }
};
```

#### 940.不同的子序列II

```c++
class Solution {
    // 定义模数
    const int MOD = 1'000'000'007;

public:
    int distinctSubseqII(string s) {
        int total = 0;
        int f[26]{};
        for (auto cur : s) {
            cur -= 'a';
            int others = (total - f[cur] + MOD) % MOD;
            f[cur] = 1 + total;
            total = (f[cur] + others) % MOD;
        }
        return total;
    }
};
```

#### 718.最长重复子数组

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        int m = nums2.size();
        int ans = 0;
        vector f(n + 1, vector<int>(m + 1));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // 两值相等则根据状态转移方程更新 f[i+1][j+1]
                if (nums1[i] == nums2[j]) {
                    f[i + 1][j + 1] = f[i][j] + 1;
                    ans = max(ans, f[i + 1][j + 1]);
                }
            }
        }
        return ans;
    }
};
```

#### 62.不同路径

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector memo(m, vector<int>(n));
        // 重点就在于找到子问题，递归，找到状态转移方程
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0 || j < 0) {
                return 0;
            }
            if (i == 0 && j == 0) {
                return 1;
            }
            int& ret = memo[i][j];
            if (ret) {
                return ret;
            }
            // 状态转移方程dfs(i,j)=dfs(i−1,j)+dfs(i,j−1)
            return ret = dfs(i - 1, j) + dfs(i, j - 1);
        };
        return dfs(m - 1, n - 1);
    }
};
```

#### 64.最小路径和

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector memo(m, vector<int>(n, -1));
        // 记忆化搜索
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0 || j < 0) {
                return INT_MAX;
            }
            if (i == 0 && j == 0) {
                return grid[i][j];
            }
            int& ret = memo[i][j];
            if (ret != -1) {
                return ret;
            }
            // 找到状态转移方程
            return ret = min(dfs(i - 1, j), dfs(i, j - 1)) + grid[i][j];
        };
        return dfs(m - 1, n - 1);
    }
};
```

#### 264.丑数II

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        // 指针初始化
        int idx2 = 0;
        int idx3 = 0;
        int idx5 = 0;
        vector<int> uglyNumbers(n);
        uglyNumbers[0] = 1;
        for (int i = 1; i < n; i++) {
            // 计算候选值
            int candidate2 = uglyNumbers[idx2] * 2;
            int candidate3 = uglyNumbers[idx3] * 3;
            int candidate5 = uglyNumbers[idx5] * 5;
            // 选择最小值
            uglyNumbers[i] = min({candidate2, candidate3, candidate5});
            // 独立更新指针
            if (uglyNumbers[i] == candidate2) {
                idx2++;
            }
            if (uglyNumbers[i] == candidate3) {
                idx3++;
            }
            if (uglyNumbers[i] == candidate5) {
                idx5++;
            }
        }
        return uglyNumbers[n - 1];
    }
};
```



---

## 哈希表（补充）

### Medium（补充）

#### 30.串联所有单词的子串

```c++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        if (words.empty()) {
            return {};
        }
        int m = words[0].size();
        int n = words.size();
        int windowLength = m * n;
        unordered_map<string, int> target;
        // 统计 words 中每个单词的出现次数
        for (auto& w : words) {
            target[w]++;
        }
        vector<int> ans;
        for (int i = 0; i < m; i++) {
            unordered_map<string, int> num;
            int overload = 0;
            for (int right = i + m; right <= s.size(); right += m) {
                // 截取新进入窗口的单词
                string in_word = s.substr(right - m, m);
                // 已达目标值，再添加会导致超限
                if (num[in_word] == target[in_word]) {
                    overload++;
                }
                num[in_word]++;
                // 计算窗口左边界
                int left = right - windowLength;
                if (left < 0) {
                    continue;
                }
                // overload=0则完全匹配
                if (overload == 0) {
                    ans.push_back(left);
                }
                // 移除窗口左侧单词
                string out_word = s.substr(left, m);
                num[out_word]--; // 减少计数
                // 若移除后计数回归目标值，超限种类数-1
                if (num[out_word] == target[out_word]) {
                    overload--;
                }
            }
        }
        return ans;
    }
};
```

#### 37.解数独

```c++
class Solution {
private:
    // 递归尝试填充数独棋盘的空格
    bool backtracking(vector<vector<char>>& board) {
        // 遍历行列
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                if (board[i][j] == '.') {
                    for (char k = '1'; k <= '9'; k++) {
                        if (check(i, j, k, board)) {
                            board[i][j] = k;
                            if (backtracking(board)) {
                                return true;
                            }
                            board[i][j] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
    // 校验函数
    bool check(int row, int col, char val, vector<vector<char>>& board) {
        // 检查当前行列是否重复
        for (int i = 0; i < 9; i++) {
            if (board[row][i] == val)
                return false;
        }
        for (int j = 0; j < 9; j++) {
            if (board[j][col] == val)
                return false;
        }
        // 检查3x3宫格是否重复
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++) {
            for (int j = startCol; j < startCol + 3; j++) {
                if (board[i][j] == val)
                    return false;
            }
        }
        return true;
    }
public:
    // 启动回溯求解
    void solveSudoku(vector<vector<char>>& board) { backtracking(board); }
};
```

#### 41.缺失的第一个正数

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int length = nums.size();
        // 遍历 找到元素值与其下标不相配的，交换
        for (int i = 0; i < length; i++) {
            while (nums[i] >= 1 && nums[i] <= length &&
                   nums[i] != nums[nums[i] - 1]) {
                int j = nums[i] - 1;
                swap(nums[i], nums[j]);
            }
        }
        // 找第一个位置和元素值不匹配的元素
        for (int i = 0; i < length; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return length + 1;
    }
};
```

#### 137.只出现一次的数字II

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int, int> hash;
        // 统计每个数字的出现频率
        for (auto cur : nums) {
            hash[cur]++;
        }
        int ans = 0;
        // 遍历哈希表，查找只出现一次的元素
        for (auto [num, occ] : hash) {
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
};
```

#### 205.同构字符串

```c++
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        // 双向映射表：s2t 记录 s→t 的映射，t2s 记录 t→s 的映射
        unordered_map<char, char> s2t;
        unordered_map<char, char> t2s;
        int n = s.length();
        for (int i = 0; i < n; i++) {
            auto x = s[i];
            auto y = t[i];
            // 检查冲突
            if ((s2t.count(x) && s2t[x] != y) ||
                (t2s.count(y) && t2s[y] != x)) {
                return false;
            }
            // 无冲突时建立双向映射
            s2t[x] = y;
            t2s[y] = x;
        }
        return true;
    }
};
```

#### 325.和等于K的最长子数组长度

```c++
class Solution {
public:
    int maxSubArrayLen(vector<int>& nums, int k) {
        long long prefixSum = 0;
        int ans = 0;
        int n = nums.size();
        unordered_map<long long, int> hash;
        hash.reserve(n + 1);
        hash.emplace(0, -1);
        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            // 检查是否存在 prefixSum - k,更新最大长度
            auto cur = hash.find(prefixSum - k);
            if (cur != hash.end()) {
                ans = max(ans, i - cur->second);
            }
            // 仅记录首次出现的前缀和索引
            hash.try_emplace(prefixSum, i);
        }
        return ans;
    }
};
```

#### 347.前K个高频元素

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 统计
        unordered_map<int, int> hash;
        int maxNum = 0;
        for (int c : nums) {
            hash[c]++;
            maxNum = max(maxNum, hash[c]);
        }
        // 桶处理
        vector<vector<int>> buckets(maxNum + 1);
        for (auto& [x, c] : hash) {
            buckets[c].push_back(x);
        }
        // 获取答案
        vector<int> ans;
        for (int i = maxNum; i >= 0 && ans.size() < k; i--) {
            ans.insert(ans.end(), buckets[i].begin(), buckets[i].end());
        }
        return ans;
    }
};
```

#### 398.随机数索引

```c++
class Solution {
    // 存储元素值到索引列表的映射
    unordered_map<int, vector<int>> pos;

public:
    Solution(vector<int>& nums) {
        // 记录元素索引
        for (int i = 0; i < nums.size(); i++) {
            pos[nums[i]].push_back(i);
        }
    }

    int pick(int target) {
        // 获取索引并随机返回
        auto& idx = pos[target];
        return idx[rand() % idx.size()];
    }
};
```

#### 438.找到字符串中所有字母异位词

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        // 哈希表+滑动窗口遍历字符串
        vector<int> ans;
        unordered_map<char, int> cnt_s;
        unordered_map<char, int> cnt_p;
        for (auto c : p) {
            cnt_p[c]++;
        }
        // 滑动窗口遍历字符串s
        for (int right = 0; right < s.size(); right++) {
            cnt_s[s[right]]++;
            int left = right - p.size() + 1;
            // 处理窗口长度不足的情况
            if (left < 0) {
                continue;
            }
            if (cnt_p == cnt_s) {
                ans.push_back(left);
            }
            cnt_s[s[left]]--;
            if (cnt_s[s[left]] == 0) {
                cnt_s.erase(s[left]);
            }
        }
        return ans;
    }
};
```

#### 560.和为K的子数组

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int ans = 0;
        int prefix = 0;
        // 哈希表记录前缀和出现的次数，初始化
        unordered_map<int, int> hash{{0, 1}};
        // 遍历数组中的每个元素
        for (auto current : nums) {
            prefix += current;
            // 检查是否存在prefix - k的前缀和，若存在则说明中间有和为k的子数组
            ans += hash.contains(prefix - k) ? hash[prefix - k] : 0;
            hash[prefix]++;
        }
        return ans;
    }
};
```

#### 594.最长和谐子序列

```c++
class Solution {
public:
    int findLHS(vector<int>& nums) {
        // 统计每个数字出现的频率
        unordered_map<int, int> hash;
        for (int x : nums) {
            hash[x]++;
        }
        int ans = 0;
        // 遍历频率哈希表，寻找相邻数字组合
        for (auto& [x, c] : hash) {
            if (hash.contains(x + 1)) {
                ans = max(ans, c + hash[x + 1]);
            }
        }
        return ans;
    }
};
```

#### 706.设计哈希映射

```c++
class MyHashMap {
private:
    vector<list<pair<int, int>>> data;
    static const int base = 769;
    // 通过取模运算将键映射到桶索引
    static int hash(int key) { return key % base; }

public:
    MyHashMap() : data(base) {}

    // 插入或更新键值对
    void put(int key, int value) {
        int h = hash(key);
        auto& bucket = data[h];
        for (auto it = bucket.begin(); it != bucket.end(); it++) {
            if (it->first == key) {
                it->second = value;
                return;
            }
        }
        bucket.push_back(make_pair(key, value));
    }
    /** 获取键对应的值，不存在返回 -1 */
    int get(int key) {
        int h = hash(key);
        auto& bucket = data[h];
        for (auto it = bucket.begin(); it != bucket.end(); it++) {
            if (it->first == key) {
                return it->second;
            }
        }
        return -1;
    }
    /** 删除键值对 */
    void remove(int key) {
        int h = hash(key);
        auto& bucket = data[h];
        for (auto it = bucket.begin(); it != bucket.end(); it++) {
            if (it->first == key) {
                bucket.erase(it);
                return;
            }
        }
    }
};
```

#### 12.整数转罗马数字

```c++
class Solution {
    // 静态常量映射表
    static constexpr string R[4][10] = {
        {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"},
        {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"},
        {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"},
        {"", "M", "MM", "MMM"}};

public:
    string intToRoman(int num) {
        // 从高位到低位拼接罗马数字
        return R[3][num / 1000] + R[2][num / 100 % 10] + R[1][num / 10 % 10] +
               R[0][num % 10];
    }
};
```



---

## 二分查找（补充）

### Medium（补充）

#### 4.寻找两个正序数组的中位数

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& a, vector<int>& b) {
        if (a.size() > b.size()) {
            swap(a, b);
        }
        int m = a.size(), n = b.size();
        a.insert(a.begin(), INT_MIN);
        b.insert(b.begin(), INT_MIN);
        a.push_back(INT_MAX);
        b.push_back(INT_MAX);
        // 枚举法
        int i = 0, j = (m + n + 1) / 2;
        while (true) {
            if (a[i] <= b[j + 1] && a[i + 1] > b[j]) {
                int max1 = max(a[i], b[j]);
                int min2 = min(a[i + 1], b[j + 1]);
                return (m + n) % 2 ? max1 : (max1 + min2) / 2.0;
            }
            i++;
            j--;
        }
    }
};
```

#### 852.山脉数组的峰顶索引

```c++
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int left = 0;
        int right = arr.size() - 2;
        // 经典二分查找
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] > arr[mid + 1]) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

#### 2563.统计公平数对的数目

```c++
class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        ranges::sort(nums);
        long long ans = 0;
        // 遍历每个元素作为右端点 j
        for (int j = 0; j < nums.size(); j++) {
            // 注意要在 [0, j-1] 中二分，因为题目要求两个下标 i < j
            auto right =
                upper_bound(nums.begin(), nums.begin() + j, upper - nums[j]);
            auto left =
                lower_bound(nums.begin(), nums.begin() + j, lower - nums[j]);
            // 累加数量
            ans += right - left;
        }
        return ans;
    }
};
```

#### 2300.咒语和药水的成功对数

```c++
class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions,
                                long long success) {
        ranges::sort(potions);
        for (auto& x : spells) {
            // 计算临界值
            long long target = (success - 1) / x;
            // 使用 upper_bound 找到第一个大于 target 的元素位置
            if (target < potions.back()) {
                x = potions.end() - ranges::upper_bound(potions, target);
            } else {
                x = 0;
            }
        }
        // 返回结果数组
        return spells;
    }
};
```

#### 1283.使结果不超过阈值的最小除数

```c++
class Solution {
public:
    int smallestDivisor(vector<int>& nums, int threshold) {
        // 给定除数 m，判断 nums 每个元素除以 m 向上取整的和是否 ≤ threshold
        auto check = [&](int m) -> bool {
            int sum = 0;
            for (int x : nums) {
                sum += (x + m - 1) / m;
                if (sum > threshold) {
                    return false;
                }
            }
            return true;
        };
        int left = 0;
        int right = ranges::max(nums);
        // 二分查找满足条件的最小除数 m
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            (check(mid) ? right : left) = mid;
        }
        return right;
    }
};
```

#### 2187.完成旅途的最小时间

```c++
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        // 给定时间 x，判断是否可以完成至少 totalTrips 次旅程
        auto check = [&](long long currentTime) -> bool {
            long long total = 0;
            for (auto t : time) {
                total += currentTime / t;
                if (total >= totalTrips) {
                    return true;
                }
            }
            return false;
        };
        // 找到 time 数组中的最小单次旅程时间
        int minTime = ranges::min(time);
        long long left = 0;
        long long right = 1LL * minTime * totalTrips;
        // 寻找满足条件的临界时间
        while (right - left > 1) {
            long long mid = left + (right - left) / 2;
            if (check(mid)) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

#### 1011.在D天内送达包裹的能力

```c++
class Solution {
public:
    int shipWithinDays(vector<int>& weights, int days) {
        // 确定二分查找左右边界
        int left = *max_element(weights.begin(), weights.end());
        int right = accumulate(weights.begin(), weights.end(), 0);
        while (left < right) {
            int mid = (left + right) / 2;
            // leastDay需要运送的天数
            int leastDay = 1;
            int cur = 0;
            for (int weight : weights) {
                if (cur + weight > mid) {
                    ++leastDay;
                    cur = 0;
                }
                cur += weight;
            }
            if (leastDay <= days) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

#### 275.H指数II

```c++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        int left = 0;
        int right = n - 1;
        // 经典二分查找，注意目标值的区别
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // 检查当前论文的引用次数是否足够支撑H指数
            if (citations[mid] < n - mid) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return n - left;
    }
};
```

#### 2529.正整数和负整数的最大计数

```c++
// 直接计数解法
class Solution {
public:
    int maximumCount(vector<int>& nums) {
        int n = nums.size();
        int negative = 0;
        int positive = 0;
        // 计算正整数和负整数的个数
        for (auto cur : nums) {
            if (cur < 0) {
                negative++;
            }
            if (cur > 0) {
                positive++;
            }
        }
        return max(negative, positive);
    }
};
// 二分查找解法
class Solution {
public:
    int maximumCount(vector<int>& nums) {
        int n = nums.size();
        // 查找第一个 >= 0 的索引（负数结束位置）
        int firstNonNeg = firstGreaterEqual(nums, 0);
        // 查找第一个 > 0 的索引（正数开始位置）
        int firstPos = firstGreaterThan(nums, 0);

        int negativeCount = firstNonNeg;  // 负数个数
        int positiveCount = n - firstPos; // 正数个数

        return max(negativeCount, positiveCount);
    }

private:
    // 二分查找：返回第一个 >= target 的索引
    int firstGreaterEqual(vector<int>& nums, int target) {
        int low = 0, high = nums.size();
        while (low < high) {
            int mid = low + (high - low) / 2; // 防溢出
            if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    // 二分查找：返回第一个 > target 的索引
    int firstGreaterThan(vector<int>& nums, int target) {
        int low = 0, high = nums.size();
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }
};
```

#### 2861.最大合金数

```c++
class Solution {
public:
    int maxNumberOfAlloys(int n, int k, int budget,
                          vector<vector<int>>& composition, vector<int>& stock,
                          vector<int>& cost) {
        int ans = 0;
        int maxNum = ranges::min(stock) + budget;
        // 遍历每台机器
        for (auto& cur : composition) {
            auto check = [&](long long num) -> bool {
                long long money = 0;
                for (int i = 0; i < n; i++) {
                    // 若库存不足，计算购买费用
                    if (stock[i] < cur[i] * num) {
                        money += (cur[i] * num - stock[i]) * cost[i];
                        // 提前终止：花费超预算
                        if (money > budget) {
                            return false;
                        }
                    }
                }
                return money <= budget;
            };
            int left = ans;
            int right = maxNum + 1;
            while (right - left > 1) {
                int mid = left + (right - left) / 2;
                // 根据检查结果更新边界
                if (check(mid)) {
                    left = mid;
                } else {
                    right = mid;
                }
            }
            ans = left;
        }
        return ans;
    }
};
```

#### 2439.最小化数组中的最大值

```c++
class Solution {
public:
    int minimizeArrayValue(vector<int>& nums) {
        auto check = [&](int limit) -> bool {
            long long extra = 0;
            int n = nums.size();
            for (int i = n - 1; i > 0; i--) {
                extra = max(nums[i] + extra - limit, 0LL);
            }
            return nums[0] + extra - limit <= 0;
        };
        // 开区间二分
        int left = -1;
        int right = ranges::max(nums);
        while (right - left > 1) {
            int mid = (left + right) / 2;
            if (check(mid)) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

#### 2517.礼盒的最大甜蜜度

```c++
class Solution {
public:
    int maximumTastiness(vector<int>& price, int k) {
        // 判断是否能在数组中选出k个元素
        auto check = [&](int d) -> int {
            int num = 1;
            int pre = price[0];
            for (auto cur : price) {
                if (cur - pre >= d) {
                    num++;
                    pre = cur;
                }
            }
            return num;
        };
        // 排序，确定二分查找边界并进行查找
        ranges::sort(price);
        int left = 0;
        int right = (price.back() - price[0]) / (k - 1) + 1;
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            if (check(mid) >= k) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return left;
    }
};
```

#### 1901.寻找峰值II

```c++
class Solution {
    // 返回一行中最大值所在的列索引
    int indexOfMax(vector<int>& a) {
        return ranges::max_element(a) - a.begin();
    }

public:
    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        int left = -1;
        int n = mat.size();
        int right = n - 1;
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            int j = indexOfMax(mat[mid]);
            // 比较当前行最大值与下一行同列元素
            if (mat[mid][j] > mat[mid + 1][j]) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return {right, indexOfMax(mat[right])};
    }
};
```

#### 154.寻找旋转排序数组中的最小值II

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = -1;
        int n = nums.size();
        int right = n - 1;
        // 二分查找
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            // 关键三路比较
            if (nums[mid] == nums[right]) {
                right--;
            } else if (nums[mid] < nums[right]) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return nums[right];
    }
};
```

#### 744.寻找比目标字母大的最小字母

```c++
// 半闭半开区间的写法
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        char ans;
        int n = letters.size();
        int left = 0;
        int right = n;
        while (left < right) {
            // 计算中间位置
            auto mid = left + (right - left) / 2;
            if (letters[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return letters[left % n];
    }
};
// 闭区间的写法
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        int n = letters.size();
        int left = 0;
        int right = n - 1;
        while (left <= right) {
            // 计算中间位置
            int mid = left + (right - left) / 2;
            if (letters[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return letters[left % n];
    }
};
```

#### 1385.两个数组间的距离值

```c++
class Solution {
public:
    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
        // 升序排序两个数组
        ranges::sort(arr1);
        ranges::sort(arr2);
        int m = arr1.size();
        int n = arr2.size();
        int right = 0;
        int ans = 0;
        // 遍历 arr1 的每个元素
        for (int left = 0; left < m; left++) {
            // 移动右指针
            while (right < n && arr1[left] - arr2[right] > d) {
                right++;
            }
            if (right == n || arr2[right] - arr1[left] > d) {
                ans++;
            }
        }
        return ans;
    }
};
```



---

## 滑动窗口（补充）

### Medium（补充）

#### 16.最接近的三数之和

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        ranges::sort(nums);
        int n = nums.size();
        int ans = nums[0] + nums[1] + nums[2];
        for (int i = 0; i <= n - 3; i++) {
            auto cur = nums[i];
            if (i > 0 && cur == nums[i - 1]) {
                continue;
            }
            // 剪枝1
            if (cur + nums[i + 1] + nums[i + 2] > target) {
                if (abs(cur + nums[i + 1] + nums[i + 2] - target) <
                    abs(ans - target)) {
                    ans = cur + nums[i + 1] + nums[i + 2];
                }
                continue;
            }
            // 剪枝2
            if (cur + nums[n - 1] + nums[n - 2] < target) {
                if (abs(cur + nums[n - 1] + nums[n - 2] - target) <
                    abs(ans - target)) {
                    ans = cur + nums[n - 1] + nums[n - 2];
                }
                continue;
            }
            int j = i + 1;
            int k = n - 1;
            while (j < k) {
                auto sum = cur + nums[j] + nums[k];
                if (sum == target) {
                    return sum;
                }
                // 更新最佳和
                if (abs(sum - target) < abs(ans - target)) {
                    ans = sum;
                }
                // 根据和与目标值的关系移动指针
                if (sum < target) {
                    for (j++; j < k && nums[j] == nums[j - 1]; j++) {
                        continue;
                    }
                } else {
                    for (k--; j < k && nums[k] == nums[k + 1]; k--) {
                        continue;
                    }
                }
            }
        }
        return ans;
    }
};
```

#### 18.四数之和

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int a = 0; a <= n - 4; a++) {
            long long x = nums[a];
            if (a > 0 && x == nums[a - 1]) {
                continue;
            }
            if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) {
                break;
            }
            if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) {
                continue;
            }
            for (int b = a + 1; b <= n - 3; b++) { // 枚举第二个数
                auto y = nums[b];
                if (b > a + 1 && y == nums[b - 1]) {
                    continue;
                }

                if (x + y + nums[b + 1] + nums[b + 2] > target) {
                    break;
                }
                if (x + y + nums[n - 2] + nums[n - 1] < target) {
                    continue;
                }
                int c = b + 1;
                int d = n - 1;
                // 双指针枚举第三个数和第四个数
                while (c < d) {
                    long long sum = x + y + nums[c] + nums[d];
                    if (sum > target) {
                        d--;
                    }
                    else if (sum < target) {
                        c++;
                    } else {
                        // sum==target
                        ans.push_back({(int)x, (int)y, nums[c], nums[d]});
                        for (c++; c < d && nums[c] == nums[c - 1]; c++) {
                            continue;
                        }
                        for (d--; d > c && nums[d] == nums[d + 1]; d--) {
                            continue;
                        }
                    }
                }
            }
        }
        return ans;
    }
};
```

#### 344.反转字符串

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int n = s.size();
        // 双指针交换，往中间靠拢
        for (int left = 0, right = n - 1; left < right; left++, right--) {
            swap(s[left], s[right]);
        }
    }
};
```

#### 611.有效三角形的个数

```c++
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        ranges::sort(nums);
        int ans = 0;
        int n = nums.size();
        // 固定最大边
        for (int i = n - 1; i >= 2; i--) {
            int left = 0;
            int right = i - 1;
            // 双指针向中间收缩
            while (left < right) {
                if (nums[left] + nums[right] > nums[i]) {
                    ans += right - left;
                    right--;
                } else {
                    left++;
                }
            }
        }
        return ans;
    }
};
```

#### 643.子数组最大平均数I

```c++
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        double ans = 0;
        double cur = 0;
        double n = nums.size();
        // 先获取初始值
        for (int i = 0; i < k; i++) {
            ans += nums[i];
        }
        // 过渡初始值并不断更新最大值
        cur = ans;
        for (int i = 1; i + k <= n; i++) {
            cur += (nums[i + k - 1] - nums[i - 1]);
            ans = max(cur, ans);
        }
        return ans / k;
    }
};
```

#### 713.乘积小于K的子数组

```c++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        // 异常情况处理
        if (k <= 1) {
            return 0;
        }
        int n = nums.size();
        int left = 0;
        int ans = 0;
        int cur = 1;
        // 遍历数组，right是滑动窗口的右边界
        for (int right = 0; right < n; right++) {
            cur *= nums[right];
            while (cur >= k) {
                cur /= nums[left];
                left++;
            }
            ans += right - left + 1;
        }
        return ans;
    }
};
```

#### 904.水果成篮

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        // 灵神不定长滑动窗口模板题
        unordered_map<int, int> hash;
        int ans = 0;
        int left = 0;
        int n = fruits.size();
        for (int right = 0; right < n; right++) {
            hash[fruits[right]]++;
            // 如果超过2种水果就移动左指针
            while (hash.size() > 2) {
                int out = fruits[left];
                hash[out]--;
                if (hash[out] == 0) {
                    hash.erase(out);
                }
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

#### 930.和相同的二元子数组

```c++
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
        int n = nums.size();
        int left1 = 0;
        int left2 = 0;
        int sum1 = 0;
        int sum2 = 0;
        int ans = 0;
        for (int right = 0; right < n; right++) {
            // 维护两个窗口并更新答案
            sum1 += nums[right];
            while (left1 <= right && sum1 > goal) {
                sum1 -= nums[left1];
                left1++;
            }
            sum2 += nums[right];
            while (left2 <= right && sum2 >= goal) {
                sum2 -= nums[left2];
                left2++;
            }
            ans += left2 - left1;
        }
        return ans;
    }
};
```

#### 977.有序数组的平方

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        int left = 0;
        int right = n - 1;
        for (int pos = n - 1; pos >= 0; pos--) {
            // 计算当前左右指针元素的平方值
            int x = nums[left] * nums[left];
            int y = nums[right] * nums[right];
            // 选择较大的平方值填充，并移动指针
            if (x > y) {
                ans[pos] = x;
                left++;
            } else {
                ans[pos] = y;
                right--;
            }
        }
        return ans;
    }
};
```

#### 1004.最大连续1的个数III

```c++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int ans = 0;
        int left = 0;
        int n = nums.size();
        unordered_map<int, int> hash;
        for (int right = 0; right < n; right++) {
            hash[nums[right]]++;
            while (hash.find(0) != hash.end() && hash[0] > k) {
                hash[nums[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

#### 1052.爱生气的书店老板

```c++
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        // 先计算有多少顾客，存入satisfy数组计算总和就是预期，然后用抑制技能看能挽回多少顾客，求挽回顾客的最大值
        int n = customers.size();
        vector<int> satisfy(n, 0);
        // 计算预期满意顾客数
        int total = 0;
        for (int i = 0; i < n; i++) {
            if (grumpy[i] == 0) {
                satisfy[i] = customers[i];
            } else {
                satisfy[i] = 0;
            }
            total += satisfy[i];
        }
        // 计算挽回的顾客的最大值
        int ans = 0;
        int cur = 0;
        for (int i = 0; i < minutes; i++) {
            if (satisfy[i] == 0) {
                cur += customers[i];
            }
        }
        ans = cur;
        // 遍历更新最大挽回顾客数
        for (int i = 1; i + minutes <= n; i++) {
            if (satisfy[i + minutes - 1] == 0 &&
                customers[i + minutes - 1] >= 0) {
                cur += customers[i + minutes - 1];
            }
            if (satisfy[i - 1] == 0 && customers[i - 1] >= 0) {
                cur -= customers[i - 1];
            }
            ans = max(cur, ans);
        }
        return ans + total;
    }
};
```

#### 1100.长度为K的无重复字符子串

```c++
class Solution {
public:
    int numKLenSubstrNoRepeats(string s, int k) {
        // 最基本的滑动窗口
        int n = s.size();
        // 当字符串长度形成不了窗口返回0即可
        if (n < k) {
            return 0;
        }
        int ans = 0;
        int cur = 0;
        unordered_map<int, int> hash;
        for (int i = 0; i < k; i++) {
            hash[s[i]]++;
        }
        if (hash.size() == k) {
            ans++;
        }
        cur = ans;
        for (int i = 1; i + k <= n; i++) {
            // 左侧元素移除
            hash[s[i - 1]]--;
            if (hash[s[i - 1]] == 0) {
                hash.erase(s[i - 1]);
            }
            // 移入右侧元素
            hash[s[i + k - 1]]++;
            if (hash.size() == k) {
                ans++;
            }
        }
        return ans;
    }
};
```

#### 1151.最少交换次数来组合所有的1

```c++
class Solution {
public:
    int minSwaps(vector<int>& data) {
        // 先计算data中1的个数，如果个数不超过1个返回0即可
        int num1 = 0;
        int n = data.size();
        for (int i = 0; i < n; i++) {
            if (data[i] == 1) {
                num1++;
            }
        }
        if (num1 <= 1) {
            return 0;
        }
        // 接下来就是计算长度num1的窗口滑动 最多能包住几个1
        int ans = 0;
        int cur = 0;
        for (int i = 0; i < num1; i++) {
            if (data[i] == 1) {
                ans++;
            }
        }
        cur = ans;
        for (int i = 1; i + num1 <= n; i++) {
            if (data[i - 1] == 1) {
                cur--;
            }
            if (data[i + num1 - 1] == 1) {
                cur++;
            }
            ans = max(cur, ans);
        }
        // 返回1的个数-最大窗口内1的个数
        return num1 - ans;
    }
};
```

#### 1176.健身计划评估

```c++
class Solution {
public:
    int dietPlanPerformance(vector<int>& calories, int k, int lower,
                            int upper) {
        // 套模板即可
        int cur = 0;
        int ans = 0;
        int n = calories.size();
        for (int i = 0; i < k; i++) {
            cur += calories[i];
        }
        if (cur > upper) {
            ans++;
        } else if (cur < lower) {
            ans--;
        } else {
            ans = 0;
        }
        for (int i = 1; i + k <= n; i++) {
            cur += calories[i + k - 1] - calories[i - 1];
            if (cur > upper) {
                ans++;
            } else if (cur < lower) {
                ans--;
            }
        }
        return ans;
    }
};
```

#### 1208.尽可能使字符串相等

```c++
class Solution {
public:
    int equalSubstring(string s, string t, int maxCost) {
        // 先判断是否有空字符串，有则直接返回0即可
        int m = s.size();
        int n = t.size();
        if (m == 0 || n == 0) {
            return 0;
        }
        int ans = 0;
        int left = 0;
        int right = 0;
        int curCost = 0;
        // 不定长滑动窗口，如果不符合条件直接移动左指针即可
        while (left <= right && right <= m - 1) {
            curCost += (abs(s[right] - t[right]));
            // 如果超预算就砍掉左边的字符
            while (curCost > maxCost) {
                curCost -= (abs(s[left] - t[left]));
                left++;
            }
            ans = max(ans, right - left + 1);
            right++;
        }
        return ans;
    }
};
```

#### 1248.统计优美子数组

```c++
class Solution {
public:
    int numberOfSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        int left1 = 0;
        int left2 = 0;
        int sum1 = 0;
        int sum2 = 0;
        int ans = 0;
        for (int right = 0; right < n; right++) {
            // 维护2个窗口并更新答案
            sum1 += nums[right] & 1;
            while (left1 <= right && sum1 > k) {
                sum1 -= nums[left1] & 1;
                left1++;
            }
            sum2 += nums[right] & 1;
            while (left2 <= right && sum2 >= k) {
                sum2 -= nums[left2] & 1;
                left2++;
            }
            ans += left2 - left1;
        }
        return ans;
    }
};
```

#### 1343.大小为K且平均值大于等于阈值的子数组数目

```c++
class Solution {
public:
    int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        int totalThreshold = k * threshold;
        int ans = 0;
        int cur = 0;
        int n = arr.size();
        // 获取初始值
        for (int i = 0; i < k; i++) {
            cur += arr[i];
        }
        // 判断是否符合条件，符合条件时则+1
        if (cur >= totalThreshold) {
            ans = 1;
        }
        for (int i = 1; i + k <= n; i++) {
            cur += (arr[i + k - 1] - arr[i - 1]);
            if (cur >= totalThreshold) {
                ans++;
            }
        }
        return ans;
    }
};
```

#### 1358.包含所有三种字符的子字符串数目

```c++
class Solution {
public:
    int numberOfSubstrings(string s) {
        // 越长越合法型滑动窗口
        int ans = 0;
        int left = 0;
        int n = s.size();
        unordered_map<int, int> hash;
        for (int right = 0; right < n; right++) {
            auto cur = s[right];
            hash[cur - 'a']++;
            // 收缩左边界
            while (hash[0] && hash[1] && hash[2]) {
                hash[s[left] - 'a']--;
                left++;
            }
            ans += left;
        }
        return ans;
    }
};
```

#### 1423.可获得的最大点数

```c++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        // 逆转思维，每次取牌左右不固定，但是总和固定，可以转化为取n-k张牌的最小值
        int n = cardPoints.size();
        int ans = 0;
        int cur = 0;
        int total = 0;
        // 求总和
        for (int i = 0; i < n; i++) {
            total += cardPoints[i];
        }
        // 初始化值
        int window = n - k;
        // 如果n-k长度不为正则直接返回total即可
        if (window <= 0) {
            return total;
        }
        for (int i = 0; i < window; i++) {
            cur += cardPoints[i];
        }
        ans = cur;
        // 遍历更新最小值
        for (int i = 1; i + window <= n; i++) {
            cur += cardPoints[i+window-1]-cardPoints[i-1];
            ans = min(cur, ans);
        }
        return total - ans;
    }
};
```

#### 1456.定长子串中元音的最大数目

```c++
class Solution {
    // 判断一个字母是否是元音字母
    bool isAEIOU(char c) {
        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {
            return true;
        } else {
            return false;
        }
    }

public:
    int maxVowels(string s, int k) {
        int n = s.size();
        int ans = 0;
        int cur = 0;
        // 先求出初始值
        for (int i = 0; i < k; i++) {
            if (isAEIOU(s[i])) {
                ans++;
            }
        }
        // 过渡初始值并求最大值
        cur = ans;
        for (int i = 1; i + k <= n; i++) {
            if (isAEIOU(s[i - 1])) {
                cur--;
            }
            if (isAEIOU(s[i + k - 1])) {
                cur++;
            }
            ans = max(cur, ans);
        }
        return ans;
    }
};
```

#### 1493.删掉一个元素以后全为1的最长子数组

```c++
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        int left = 0;
        unordered_map<int, int> hash;
        for (int right = 0; right < n; right++) {
            auto cur = nums[right];
            hash[cur]++;
            while (hash[0] > 1) {
                hash[nums[left]]--;
                left++;
            }
            ans = max(ans, right - left);
        }
        return ans;
    }
};
```

#### 1652.拆炸弹

```c++
class Solution {
public:
    vector<int> decrypt(vector<int>& code, int k) {
        int n = code.size();
        // 处理k=0的特殊情况
        if (k == 0) {
            return vector<int>(n, 0);
        }
        // 创建3倍长度的数组处理环形结构
        vector<int> newCode(3 * n);
        for (int i = 0; i < 3 * n; i++) {
            newCode[i] = code[i % n];
        }
        vector<int> ans(n);
        int len = abs(k);
        int left = 0;
        int right = 0;
        int windowSum = 0;
        if (k > 0) {
            left = n + 1;
            right = n + k;
        } else {
            left = n + k; 
            right = n - 1;
        }
        // 计算初始窗口和
        for (int i = left; i <= right; i++) {
            windowSum += newCode[i];
        }
        // 滑动窗口处理每个位置
        for (int i = n; i < 2 * n; i++) {
            ans[i - n] = windowSum;
            // 窗口滑动
            windowSum -= newCode[left];
            left++;
            right++;
            windowSum += newCode[right];
        }
        return ans;
    }
};
```

#### 1658.将X减到0的最小操作数

```c++
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        // 计算数组总和
        int total = accumulate(nums.begin(), nums.end(), 0);
        int target = total - x;
        int n = nums.size();
        if (target < 0) {
            return -1;
        }
        int left = 0;
        int curSum = 0;
        int ans = -1;
        for (int right = 0; right < n; right++) {
            // 拓展右边界，收缩左边界
            curSum += nums[right];
            while (curSum > target) {
                curSum -= nums[left];
                left++;
            }
            // 更新最大窗口长度
            if (curSum == target) {
                ans = max(ans, right - left + 1);
            }
        }
        return (ans != -1) ? n - ans : -1;
    }
};
```

#### 1695.删除子数组的最大得分

```c++
class Solution {
public:
    int maximumUniqueSubarray(vector<int>& nums) {
        // 左右指针滑动，如果右指针摸到的元素和左指针相同，移动左指针
        int ans = 0;
        int left = 0;
        int n = nums.size();
        // 当前窗口元素和
        int currentSum = 0;
        unordered_map<int, int> hash;
        for (int right = 0; right < n; right++) {
            int cur = nums[right];
            currentSum += cur;
            // 如果新入元素已经存在，移除元素并从当前和中减去该元素值
            if (hash.find(cur) != hash.end() && hash[cur] >= left) {
                while (left <= hash[cur]) {
                    currentSum -= nums[left];
                    left++;
                }
            }
            // 更新元素最后出现的位置
            hash[cur] = right;
            ans = max(ans, currentSum);
        }
        return ans;
    }
};
```

#### 1750.删除字符串两端相同字符后的最短长度

```c++
class Solution {
public:
    int minimumLength(string s) {
        int n = s.size();
        int left = 0;
        int right = n - 1;
        while (left < right && s[left] == s[right]) {
            char cur = s[left];
            // 跳过左侧连续相同字符
            while (left <= right && s[left] == cur) {
                left++;
            }
            // 跳过右侧连续相同字符
            while (left <= right && s[right] == cur) {
                right--;
            }
        }
        return right - left + 1;
    }
};
```

