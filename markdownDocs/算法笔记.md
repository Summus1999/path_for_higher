# 算法笔记

## 数组

### Easy

#### 88.合并两个有序数组

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // 从后往前比较和填充，避免覆盖nums1中的有效元素
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        // 从后往前比较和填充
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k] = nums1[i];
                i--;
            } else {
                nums1[k] = nums2[j];
                j--;
            }
            k--;
        }
        // 剩余元素复制到nums1
        while (j >= 0) {
            nums1[k] = nums2[j];
            j--;
            k--;
        }
    }
};
```

#### 121.买卖股票的最佳时机

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        int minPrice = prices[0];
        int cur = prices[0];
        int n = prices.size();
        // 更新最大利润ans和最低价格minPrice
        for (int i = 0; i < n; i++) {
            cur = prices[i];
            ans = max(ans, cur - minPrice);
            minPrice = min(minPrice, cur);
        }
        return ans;
    }
};
```

#### 283.移动零

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int write = 0;
        // 原地覆盖非零元素
        for (int read = 0; read < n; read++) {
            if (nums[read] != 0) {
                nums[write] = nums[read];
                write++;
            }
        }
        // 原地将剩余位置置为0
        while (write < n) {
            nums[write] = 0;
            write++;
        }
    }
};
```

#### 1013.将数组分成和相等的三个部分

```c++
class Solution {
public:
    bool canThreePartsEqualSum(vector<int>& arr) {
        int total = accumulate(arr.begin(), arr.end(), 0);
        if (total % 3 != 0) {
            return false;
        }
        int target = total / 3;
        int findCount = 0;
        int curSum = 0;
        for (auto cur : arr) {
            curSum += cur;
            if (curSum == target) {
                findCount++;
                // 重置，开始下一段
                curSum = 0;
            }
        }
        return findCount >= 3;
    }
};
```

### Medium

#### 15.三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        ranges::sort(nums);
        int n = nums.size();
        vector<vector<int>> ans;
        for (int i = 0; i < n - 2; i++) {
            int x = nums[i];
            // 去重 a
            if (i > 0 && x == nums[i - 1]) {
                continue;
            }
            // 提前退出：如果最小值都大于0，后面不可能有解
            if (x > 0) {
                break;
            }
            // 剪枝：最小的三个数之和大于0
            if (x + nums[i + 1] + nums[i + 2] > 0) {
                break;
            }
            // 剪枝：当前 a 加上最大的两个数小于0
            if (x + nums[n - 2] + nums[n - 1] < 0) {
                continue;
            }
            int j = i + 1;
            int k = n - 1;
            while (j < k) {
                long long sum = static_cast<long long>(x) + nums[j] + nums[k];
                if (sum < 0) {
                    j++;
                } else if (sum > 0) {
                    k--;
                } else {
                    ans.push_back({x, nums[j], nums[k]});
                    // 去重
                    j++;
                    while (j < k && nums[j] == nums[j - 1]) {
                        j++;
                    }
                    k--;
                    while (j < k && nums[k] == nums[k + 1]) {
                        k--;
                    }
                }
            }
        }
        return ans;
    }
};
```

#### 53.最大子数组和

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 卡丹算法
        int ans = nums[0];
        int currentSum = nums[0];
        int n = nums.size();
        for (int i = 1; i < n; i++) {
            currentSum = max(nums[i], currentSum + nums[i]);
            ans = max(ans, currentSum);
        }
        return ans;
    }
};
```

#### 55.跳跃游戏

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        // 记录当前能够到达的最远下标
        int maxDistance=0;
        for (int i = 0; i < n; i++) {
            // 当前下标已经超出范围返回false
            if (i > maxDistance) {
                return false;
            }
            maxDistance = max(maxDistance, i + nums[i]);
        }
        return true;
    }
};
```

#### 189.轮转数组

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        // 计算有效旋转步数
        k %= nums.size();
        // 三步反转实现轮转
        ranges::reverse(nums);
        reverse(nums.begin(), nums.begin() + k);
        reverse(nums.begin() + k, nums.end());
    }
};
```

#### 75.颜色分类

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n=nums.size();
        int red=0;
        int white=0;
        int blue=0;
        for(auto num:nums){
            if(num==0){
                red++;
            }else if(num==1){
                white++;
            }else{
                blue++;
            }
        }
        for(int i=0;i<n;i++){
            if(i>=0&&i<red){
                nums[i]=0;
            }else if(i>=red+white){
                nums[i]=2;
            }else{
                nums[i]=1;
            }
        }
    }
};
```

#### 26.删除有序数组中的重复项

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        // 双指针法，如果vector长度为0则返回
        int n = nums.size();
        if (!n) {
            return 0;
        }
        int slow = 1;
        int fast = 1;
        // 如果fast指针遇到前后数字不相等则数字不重复，赋值给slow指针即可
        while (fast < n) {
            if (nums[fast] != nums[fast - 1]) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

#### 380.O(1)时间插入、删除和获取随机元素

```c++
class RandomizedSet {
private:
    std::vector<int> nums;
    std::unordered_map<int, int> indices;

public:
    // 初始化随机数种子
    RandomizedSet() { srand((unsigned)time(NULL)); }
    // 插入元素
    bool insert(int val) {
        if (indices.count(val)) {
            return false;
        }
        int index = nums.size();
        nums.emplace_back(val);
        indices[val] = index;
        return true;
    }
    // 移除元素
    bool remove(int val) {
        if (!indices.count(val)) {
            return false;
        }
        int index = indices[val];
        int last = nums.back();
        // 用最后一个元素覆盖待删除元素
        nums[index] = last;
        indices[last] = index;
        nums.pop_back();
        indices.erase(val);
        return true;
    }
    // 生成随机索引
    int getRandom() {
        int randomIndex = rand() % nums.size();
        return nums[randomIndex];
    }
};
```

---

## 链表

### Easy

#### 21.合并两个有序链表

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 加一个dummy节点避免处理头节点
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;
        // 双指针遍历两个链表，每次将较小的节点接到合并链表末尾
        while (list1 && list2) {
            if (list1->val <= list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        // 拼接剩余链表，并返回头节点
        cur->next = list1 ? list1 : list2;
        return dummy->next;
    }
};
```

#### 160.相交链表

```c++
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode* p1=headA;
        ListNode* p2=headB;
        // 双指针法，不相遇则遍历
        while(p1!=p2){
            if(p1==nullptr){
                p1=headB;
            }else{
                p1=p1->next;
            }
            if(p2==nullptr){
                p2=headA;
            }else{
                p2=p2->next;
            }
        }
        return p1;
    }
};
```

#### 206.反转链表

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre=nullptr;
        // cur指向当前正在处理的节点
        ListNode *cur=head;
        // 遍历整个链表
        while(cur){
            ListNode *next=cur->next;
            cur->next=pre;
            pre=cur;
            cur=next;
        }
        return pre;
    }
};
```

#### 141.环形链表

```c++
class Solution {
public:
    bool hasCycle(ListNode* head) {
        // 快慢指针，相遇成环
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
};
```

### Medium

#### 142.环形链表II

```c++
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        struct ListNode* slow = head;
        struct ListNode* fast = head;
        // 快慢指针，如果2个指针相遇后慢指针还要走一个a的距离到入环口
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                while (slow != head) {
                    slow = slow->next;
                    head = head->next;
                }
                return slow;
            }
        }
        return NULL;
    }
};
```

#### 19.删除链表的倒数第N个结点

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 快慢指针
        ListNode dummy = {0, head};
        ListNode* left = &dummy;
        ListNode* right = &dummy;
        for (int i = 1; i <= n; i++) {
            right = right->next;
        }
        // 右指针到倒数第二个节点
        while (right->next) {
            left = left->next;
            right = right->next;
        }
        // 跳过左指针的下一个节点即可
        ListNode* nxt = left->next;
        left->next = left->next->next;
        delete nxt;
        return dummy.next;
    }
};
```

#### 2.两数相加

```c++
// 初始化答案为一个「空链表」，每次循环，向该链表末尾添加一个节点（保存一个数位）
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 构造哨兵节点
        ListNode dummy;
        ListNode* current = &dummy;
        int carry = 0;
        // 每个结点保存一个数位
        while (l1 || l2 || carry) {
            if (l1) {
                carry += l1->val;
                l1 = l1->next;
            }
            if (l2) {
                carry += l2->val;
                l2 = l2->next;
            }
            ListNode* newNode = new ListNode(carry % 10);
            current->next = newNode;
            current = newNode;
            carry /= 10;
        }
        return dummy.next;
    }
};
```

#### 24.两两交换链表中的节点

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // 创建哨兵节点
        ListNode dummy{0, head};
        ListNode* node0 = &dummy;
        ListNode* node1 = head;
        while (node1 && node1->next) {
            // 定义临时指针
            ListNode* node2 = node1->next;
            ListNode* node3 = node2->next;
            // 交换2个节点
            node0->next = node2;
            node2->next = node1;
            // 链表下一个指针指向下一个需要交换的节点
            node1->next = node3;
            // 更新指针
            node0 = node1;
            node1 = node3;
        }
        return dummy.next;
    }
};
```

#### 25.K个一组翻转链表

```c++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // 计算节点数
        int nodeNum = 0;
        for (ListNode* current = head; current != NULL;
             current = current->next) {
            nodeNum++;
        }
        ListNode dummy{0,head};
        ListNode *p0=&dummy;
        ListNode *pre=nullptr;
        ListNode *current=head;
        for(int i=nodeNum;i>=k;i-=k){
            // k个结点为一组进行翻转
            for(int i=0;i<k;i++){
                ListNode *nxt=current->next;
                current->next=pre;
                pre=current;
                current=nxt;
            }
            // 将当前节点移动到下一组翻转的节点的头节点
            ListNode *nxt=p0->next;
            p0->next->next=current;
            p0->next=pre;
            p0=nxt;
        }
        return dummy.next;
    }
};
```

#### 138.随机链表的复制

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        // 先判断空节点的情况
        if (!head) {
            return nullptr;
        }
        // 遍历复制每个节点，吧新节点插到老节点后面
        for (Node* cur = head; cur; cur = cur->next->next) {
            Node* newNode = new Node(cur->val, cur->next, nullptr);
            cur->next = newNode;
        }
        // 设置新节点的random指针
        for (Node* cur = head; cur; cur = cur->next->next) {
            // 如果原节点的 random 指针不为空，新节点的 random 指针指向原节点的
            // random 指针的下一个节点
            if (cur->random) {
                cur->next->random = cur->random->next;
            }
        }
        // 双链表分离
        Node* newHead = head->next;
        Node* current = head;
        while (current->next->next) {
            Node* copy = current->next;
            current->next = copy->next;
            copy->next = copy->next->next;
            current = current->next;
        }
        // 处理最后一个节点
        current->next = nullptr;
        return newHead;
    }
};
```

#### 146.LRU缓存

```c++
class Node {
public:
    int key;
    int value;
    Node* prev;
    Node* next;
    Node(int k = 0, int v = 0) : key(k), value(v) {}
};

class LRUCache {
private:
    int capacity;
    Node* dummy;
    unordered_map<int, Node*> key_to_node;

    // 删除一个节点
    void remove(Node* x) {
        x->prev->next = x->next;
        x->next->prev = x->prev;
    }

    // 在链表头添加一个节点
    void push_front(Node* x) {
        x->prev = dummy;
        x->next = dummy->next;
        x->prev->next = x;
        x->next->prev = x;
    }

    // 获取 key 对应的节点，同时把该节点移到链表头部
    Node* get_node(int key) {
        auto it = key_to_node.find(key);
        if (it == key_to_node.end()) {
            return nullptr;
        }
        Node* node = it->second;
        remove(node);
        push_front(node);
        return node;
    }

public:
    LRUCache(int capacity) : capacity(capacity), dummy(new Node()) {
        dummy->prev = dummy;
        dummy->next = dummy;
    }

    int get(int key) {
        Node* node = get_node(key);
        return node ? node->value : -1;
    }

    void put(int key, int value) {
        // get_node 会把对应节点移到链表头部
        Node* node = get_node(key);
        if (node) {
            node->value = value;
            return;
        }
        key_to_node[key] = node = new Node(key, value);
        push_front(node);
        if (key_to_node.size() > capacity) {
            Node* back_node = dummy->prev;
            key_to_node.erase(back_node->key);
            remove(back_node);
            delete back_node;
        }
    }
};
```

---

## 动态规划

### Easy

#### 70.爬楼梯

```c++
// 解法1
class Solution {
public:
    int climbStairs(int n) {
        // 记忆化数组
        vector<int> memory(n + 1, 0);
        auto dfs = [&](this auto&& self, int i) -> int {
            // 递归终止
            if (i <= 1) {
                return 1;
            }
            // 已计算则直接返回
            int& ret = memory[i];
            if (ret) {
                return ret;
            }
            return ret = self(i - 1) + self(i - 2);
        };
        return dfs(n);
    }
};
// 解法2
class Solution {
    vector<int> memory;
    // 记忆化
    int dfs(int i) {
        if (i <= 1) {
            return 1;
        }
        // 检查是否已计算过当前结果
        int& ret = memory[i];
        if (ret) {
            return ret;
        }
        // 递归：爬到第 i 阶 = 爬到第 i-1 阶 + 爬到第 i-2 阶
        return ret = dfs(i - 2) + dfs(i - 1);
    }

public:
    int climbStairs(int n) {
        memory.resize(n + 1);
        return dfs(n);
    }
};
```

### Medium

#### 198.打家劫舍

```c++
// 记忆化搜索解法
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        // 记忆化数组存储子数组结果
        vector<int> memo(n, -1);
        auto dfs = [&](this auto&& dfs, int i) -> int {
            // 无房屋可抢劫，返回0
            if (i < 0) {
                return 0;
            }
            // 抢劫过的房屋直接返回结果
            if (memo[i] != -1) {
                return memo[i];
            }
            // 计算最大抢劫金额
            return memo[i] = max(dfs(i - 1), dfs(i - 2) + nums[i]);
        };
        // 反向遍历房屋
        return dfs(n - 1);
    }
};
// 状态压缩解法
class Solution {
public:
    int rob(vector<int>& nums) {
        int f0 = 0;
        int f1 = 0;
        // 遍历每个房屋的金额
        for (auto x : nums) {
            // 计算最大收益
            int new_f = max(f1, f0 + x);
            // 更新状态
            f0 = f1;
            f1 = new_f;
        }
        // 返回最大收益
        return f1;
    }
};
```

#### 322.零钱兑换

```c++
// 记忆化搜索解法
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        // 记忆化数组并初始化
        vector memo(n, vector<int>(amount + 1, -1));
        auto dfs = [&](this auto&& dfs, int coinNum, int remainCoin) -> int {
            // 硬币用尽
            if (coinNum < 0) {
                return remainCoin == 0 ? 0 : INT_MAX / 2;
            }
            // 当前硬币面值大于剩余金额：无法使用该硬币
            int& res = memo[coinNum][remainCoin];
            if (res != -1) {
                return res;
            }
            // 核心决策
            if (remainCoin < coins[coinNum]) {
                return res = dfs(coinNum - 1, remainCoin);
            }
            return res = min(dfs(coinNum - 1, remainCoin),
                             dfs(coinNum, remainCoin - coins[coinNum]) + 1);
        };
        int ans = dfs(n - 1, amount);
        return ans < INT_MAX / 2 ? ans : -1;
    }
};
// 完全背包解法
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dpTable(amount + 1, INT_MAX / 2);
        dpTable[0] = 0;
        for (auto coin : coins) {
            // 从当前硬币面值开始，更新到目标金额的状态
            for (int cur = coin; cur <= amount; cur++) {
                // 是否使用当前硬币可减少硬币数量
                dpTable[cur] = min(dpTable[cur], dpTable[cur - coin] + 1);
            }
        }
        int minCoins = dpTable[amount];
        return minCoins < INT_MAX / 2 ? minCoins : -1;
    }
};
```

#### 1143.最长公共子序列

```c++
// 记忆化搜索解法
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        vector memo(m, vector<int>(n, -1));
        // 递归搜索 + 保存计算结果 = 记忆化搜索
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0 || j < 0) {
                return 0;
            }
            int& ret = memo[i][j];
            if (ret != -1) {
                return ret;
            }
            if (text1[i] == text2[j]) {
                return ret = dfs(i - 1, j - 1) + 1;
            }
            return ret = max(dfs(i - 1, j), dfs(i, j - 1));
        };
        return dfs(m - 1, n - 1);
    }
};
// 线性DP解法
class Solution {
public:
    int longestCommonSubsequence(string s, string t) {
        int m = t.size();
        vector<int> dp(m + 1, 0);
        for (auto cur : s) {
            int pre = dp[0];
            for (int j = 0; j < m; j++) {
                int tmp = dp[j + 1];
                // 字符匹配时取左上角值+1，否则取上方或左方最大值
                if (cur == t[j]) {
                    dp[j + 1] = pre + 1;
                } else {
                    dp[j + 1] = max(dp[j + 1], dp[j]);
                }
                // 更新pre
                pre = tmp;
            }
        }
        return dp[m];
    }
};
```

#### 72.编辑距离

```c++
// 记忆化搜索解法
class Solution {
public:
    int minDistance(string word1, string word2) {
        // 递归搜索 + 保存计算结果 = 记忆化搜索
        int m = word1.size();
        int n = word2.size();
        vector memo(m, vector<int>(n, -1));
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0) {
                return j + 1;
            }
            if (j < 0) {
                return i + 1;
            }
            int& ret = memo[i][j];
            if (ret != -1) {
                return ret;
            }
            if (word1[i] == word2[j]) {
                return ret = dfs(i - 1, j - 1);
            }
            return ret = min({dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1)}) + 1;
        };
        return dfs(m - 1, n - 1);
    }
};
// 线性DP解法
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word2.size();
        vector<int> dp(m + 1, 0);
        // 初始化
        for (int j = 0; j < m; j++) {
            dp[j + 1] = j + 1;
        }
        for (auto cur : word1) {
            int pre = dp[0];
            dp[0]++;
            for (int j = 0; j < m; j++) {
                int tmp = dp[j + 1];
                if (cur == word2[j]) {
                    dp[j + 1] = pre;
                } else {
                    dp[j + 1] = min({dp[j + 1], dp[j], pre}) + 1;
                }
                pre = tmp;
            }
        }
        return dp[m];
    }
};
```

#### 120.三角形最小路径和

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        // 存储动态规划过程中的状态
        auto f = triangle[n - 1];
        // 由顶到底的最短路径取决于它下方相邻的两个位置
        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                f[j] = min(f[j], f[j + 1]) + triangle[i][j];
            }
        }
        return f[0];
    }
};
```

---

## 哈希表

### Easy

#### 1.两数之和

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        unordered_map<int, int> hash;
        // 使用哈希表来存储已经遍历过的数字及其索引
        for (int i = 0; i < n; i++) {
            auto current = nums[i];
            // 查找 target - current 是否在哈希表中
            auto it = hash.find(target - current);
            if (it != hash.end()) {
                return {it->second, i};
            }
            hash[current] = i;
        }
        return {};
    }
};
```

### Medium

#### 49.字母异位词分组

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> map;
        // 遍历输入字符串并分组
        for (auto s : strs) {
            string sort_s = s;
            sort(sort_s.begin(), sort_s.end());
            map[sort_s].push_back(s);
        }
        // 哈希表转换为结果
        vector<vector<string>> result;
        result.reserve(map.size());
        for (auto cur : map) {
            result.push_back(cur.second);
        }
        return result;
    }
};
```

#### 128.最长连续序列

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int ans = 0;
        // 哈希集合初始化并去重
        unordered_set<int> hash(nums.begin(), nums.end());
        for (int left : hash) {
            // 寻找序列起点
            if (hash.contains(left - 1)) {
                continue;
            }
            // 寻找序列终点
            int right = left + 1;
            while (hash.contains(right)) {
                right++;
            }
            ans = max(ans, right - left);
        }
        // 输出答案
        return ans;
    }
};
```

---

## 二分查找

### Easy

#### 35.搜索插入位置

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int length = nums.size();
        int left = 0;
        int right = length - 1;
        // 二分查找模板题
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

#### 69.X的平方根

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0 || x == 1)
            return x;
        int left = 1;
        int right = min(x, 46340);
        int ans = 0;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // 用除法替代乘法
            if (mid <= x / mid) {
                ans = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return ans;
    }
};
```

#### 704.二分查找

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // 和之前的模板有点不同，要在循环中找到结果就直接输出
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
};
```

### Medium

#### 33.搜索旋转排序数组

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int end = nums.back();
        // 构建虚拟数组check
        auto check = [&](int i) -> bool {
            int x = nums[i];
            if (x > end) {
                return target > end && x >= target;
            }
            return target > end || x >= target;
        };
        // 进行二分查找
        int left = -1;
        int right = nums.size() - 1;
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            if(check(mid)){
                right=mid;
            }else{
                left=mid;
            }
        }
        return nums[right] == target ? right : -1;
    }
};
```

#### 34.在排序数组中查找元素的第一个和最后一个位置

```c++
class Solution {
private:
    int lower_bound(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        // 这里需要加=是因为要找到第一个大于等于target的位置
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }

public:
    vector<int> searchRange(vector<int>& nums, int target) {
        // 查找target的起始位置
        int start = lower_bound(nums, target);
        if (start == nums.size() || nums[start] != target) {
            return {-1, -1};
        }
        // 查找target+1的起始位置，减1得到target的结束位
        int end = lower_bound(nums, target + 1) - 1;
        // 返回找到的起始和结束位置
        return {start, end};
    }
};
```

#### 74.搜索二维矩阵

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        int left = -1;
        int right = m * n;
        // 把矩阵从左上到右下排成一个大数组，进行二分查找即可
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            int cur = matrix[mid / n][mid % n];
            if (cur == target) {
                return true;
            }
            if (cur < target) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return false;
    }
};
```

#### 153.寻找旋转排序数组中的最小值

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = -1;
        int right = nums.size() - 1;
        // 和最后一个数比大小，进行二分查找
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < nums.back()) {
                right = mid;
            } else
                left = mid;
        }
        return nums[right];
    }
};
```

#### 162.寻找峰值

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = -1;
        int right = nums.size() - 1;
        while (left + 1 < right) {
            auto mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

#### 875.爱吃香蕉的阿珂

```c++
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        auto check = [&](int k) -> bool {
            int sum = piles.size();
            for (auto p : piles) {
                // 计算当前堆能否吃完，吃不完返回FALSE
                sum += (p - 1) / k;
                if (sum > h) {
                    return false;
                }
            }
            return true;
        };
        int left = 0;
        int right = ranges::max(piles);
        // 二分查找
        while (right - left > 1) {
            int mid = left + (right - left) / 2;
            if (check(mid)) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
};
```

---

## 滑动窗口

### Medium

#### 3.无重复字符的最长子串

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int left = 0;
        int ans = 0;
        unordered_map<int, int> hash;
        // 使用哈希表，如果有某个元素的频率超过1就缩小窗口
        for (int right = 0; right < n; right++) {
            auto cur = s[right];
            hash[cur]++;
            while (hash[cur] > 1) {
                hash[s[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

#### 76.最小覆盖子串

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        // 初始化最小窗口边界
        int ans_left = -1;
        int ans_right = s.length();
        int hash[128]{};
        int debt = 0;
        // 遍历字符串并初始化哈希表
        for (auto cur : t) {
            if (hash[cur] == 0) {
                debt++;
            }
            hash[cur]++;
        }
        // 初始化滑动窗口左指针
        int left = 0;
        for (int right = 0; right < s.length(); right++) {
            char c = s[right];
            hash[c]--;
            if (hash[c] == 0) {
                debt--;
            }
            // 满足覆盖条件下缩小窗口
            while (debt == 0) {
                if (right - left < ans_right - ans_left) {
                    ans_left = left;
                    ans_right = right;
                }
                char current = s[left];
                if (hash[current] == 0) {
                    debt++;
                }
                hash[current]++;
                left++;
            }
        }
        return (ans_left < 0) ? ""
                              : s.substr(ans_left, ans_right - ans_left + 1);
    }
};
```

#### 209.长度最小的子数组

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int ans = n + 1;
        int left = 0;
        int currentNum = 0;
        for (int right = 0; right < n; right++) {
            currentNum += nums[right];
            // 如果当前窗口和大于target直接缩窗即可，更新ans
            while (currentNum >= target) {
                ans = min(ans, right - left + 1);
                currentNum -= nums[left];
                left++;
            }
        }
        return (ans <= n) ? ans : 0;
    }
};
```

#### 239.滑动窗口最大值

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> ans; 
        deque<int> q;    
        for (int i = 0; i < nums.size(); i++) {
            // 维护队列单调性：从队尾移除比当前元素小的索引
            while (!q.empty() && nums[q.back()] <= nums[i]) {
                q.pop_back();
            }
            q.push_back(i);
            // 移除超出窗口范围的队首元素
            if (!q.empty() && q.front() <= i - k) {
                q.pop_front();
            }
            // 记录当前窗口最大值
            if (i >= k - 1) {
                ans.push_back(nums[q.front()]);
            }
        }
        return ans;
    }
};
```

#### 424.替换后的最长重复字符

```c++
class Solution {
public:
    int characterReplacement(string s, int k) {
        int n = s.size();
        int ans = 0;
        int left = 0;
        // 统计窗口内各字符出现次数
        vector<int> cnt(26);
        for (int right = 0; right < n; right++) {
            cnt[s[right] - 'A']++;
            // 当前窗口中最 frequent 字符的数量
            int maxCnt = ranges::max(cnt);
            // 需要替换的字符数 = 窗口大小 - 最 frequent 字符数
            while (right - left + 1 - maxCnt > k) {
                cnt[s[left] - 'A']--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

---

## 双指针

### Easy

#### 125.验证回文串

```c++
class Solution {
public:
    bool isPalindrome(string s) {
        int left = 0;
        int n = s.size();
        int right = n - 1;
        // 相向双指针解法
        while (left <= right) {
            if (!isalnum(s[left])) {
                left++;
            } else if (!isalnum(s[right])) {
                right--;
            } else if (tolower(s[left]) == tolower(s[right])) {
                left++;
                right--;
            } else {
                return false;
            }
        }
        return true;
    }
};
```

#### 283.移动零

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int left = 0;
        for (int right = 0; right < n; right++) {
            // 遇到非0的值直接交换
            if (nums[right]) {
                swap(nums[left], nums[right]);
                left++;
            }
        }
    }
};
```

### Medium

#### 11.盛最多水的容器

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        int ans = 0;
        int left = 0;
        int right = n - 1;
        while (left < right) {
            // 计算面积，左右挡板谁矮谁移动，搜最大值
            auto area = (right - left) * min(height[left], height[right]);
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
            ans = max(ans, area);
        }
        return ans;
    }
};
```

#### 15.三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        // 预处理排序
        ranges::sort(nums);
        int n = nums.size();
        vector<vector<int>> ans;
        // 遍历数组，固定第一个数x
        for (int i = 0; i <= n - 3; i++) {
            auto x = nums[i];
            // 剪枝优化
            if (i != 0 && x == nums[i - 1]) {
                continue;
            }
            if (x + nums[i + 1] + nums[i + 2] > 0) {
                break;
            }
            if (x + nums[n - 2] + nums[n - 1] < 0) {
                continue;
            }
            // 双指针法：j从i+1开始，k从末尾开始
            auto j = i + 1;
            auto k = n - 1;
            while (j < k) {
                auto sum = x + nums[j] + nums[k];
                if (sum > 0) {
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    ans.push_back({x, nums[j], nums[k]});
                    // 剪枝优化
                    for (j++; j < k && nums[j] == nums[j - 1]; j++) {
                        continue;
                    }
                    for (k--; j < k && nums[k] == nums[k + 1]; k--) {
                        continue;
                    }
                }
            }
        }
        return ans;
    }
};
```

#### 42.接雨水

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int ret = 0;
        int prefix = 0;
        int suffix = 0;
        // 相向双指针，谁小谁移动，同时计算雨水量即可
        while (left < right) {
            prefix = fmax(prefix, height[left]);
            suffix = fmax(suffix, height[right]);
            if (height[left] < height[right]) {
                ret += prefix - height[left];
                left++;
            } else {
                ret += suffix - height[right];
                right--;
            }
        }
        return ret;
    }
};
```

#### 167.两数之和II-输入有序数组

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        // 双指针解题，根据题目数组元素非递减解即可
        int length = numbers.size();
        int left = 0;
        int right = length - 1;
        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (sum == target) {
                return {left + 1, right + 1};
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
        return {-1, -1};
    }
};
```

---

## 二叉树

### Easy

#### 94.二叉树的中序遍历

```c++
class Solution {
    void traversal(TreeNode* cur, vector<int>& vec) {
        // 递归终止条件：当前节点为空
        if (!cur) {
            return;
        }
        // 递归遍历左子树,访问当前节点，递归遍历右子树
        traversal(cur->left, vec);
        vec.push_back(cur->val);
        traversal(cur->right, vec);
    }

public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        // 从根节点开始递归遍历
        traversal(root, ans);
        return ans;
    }
};
```

#### 100.相同的树

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 当前节点如果为空，左右子树必须都是nullptr
        if (q == nullptr || p == nullptr) {
            return q == p;
        }
        // 遍历左右子树
        return q->val == p->val && isSameTree(p->left, q->left) &&
               isSameTree(p->right, q->right);
    }
};
```

#### 101.对称二叉树

```c++
class Solution {
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 处理有空指针的情况
        if (!p || !q) {
            return p == q;
        }
        // 二叉树对称需要值相等且左右子树镜像对称
        return p->val == q->val && isSameTree(p->right, q->left) &&
               isSameTree(p->left, q->right);
    }

public:
    bool isSymmetric(TreeNode* root) {
        return isSameTree(root->left, root->right);
    }
};
```

#### 104.二叉树的最大深度

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        // 递归寻找左右子树的深度，找一个最大值然后+1即可
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        return max(leftDepth, rightDepth) + 1;
    }
};
```

### Medium

#### 102.二叉树的层序遍历

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        // 若根节点为空，直接返回空二维数组
        if (!root) {
            return {};
        }
        vector<vector<int>> ans;
        queue<TreeNode*> q;
        q.push(root);
        // 循环处理直到队列为空
        while (!q.empty()) {
            vector<int> vals;
            // 保存当前层节点数
            for (int n = q.size(); n > 0; n--) {
                auto node = q.front();
                q.pop();
                vals.push_back(node->val);
                // 将非空子节点加入队列
                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
            // 存入结果
            ans.emplace_back(vals);
        }
        return ans;
    }
};
```

#### 103.二叉树的锯齿形层序遍历

```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        if (!root) {
            return {};
        }
        vector<vector<int>> ans;
        vector<TreeNode*> cur = {root};
        bool leftToRight = true;
        while (!cur.empty()) {
            vector<TreeNode*> nxt;
            vector<int> vals;
            vals.reserve(cur.size());
            // 遍历当前层节点
            for (auto node : cur) {
                // 从左往右就尾插，否则头插
                if (leftToRight) {
                    vals.push_back(node->val);
                } else {
                    vals.insert(vals.begin(), node->val);
                }
                // 子节点入队
                if (node->left) {
                    nxt.push_back(node->left);
                }
                if (node->right) {
                    nxt.push_back(node->right);
                }
            }
            cur = move(nxt);            
            ans.push_back(move(vals));  
            leftToRight = !leftToRight; 
        }
        return ans;
    }
};
```

#### 105.从前序与中序遍历序列构造二叉树

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (preorder.empty()) {
            return nullptr;
        }
        // 确定根节点
        int left_size = ranges::find(inorder, preorder[0]) - inorder.begin();
        // 构建左子树的前序遍历 中序遍历
        vector<int> pre1(preorder.begin() + 1,
                         preorder.begin() + 1 + left_size);
        vector<int> in1(inorder.begin(), inorder.begin() + left_size);
        // 构建右子树的前序遍历 中序遍历
        vector<int> pre2(preorder.begin() + 1 + left_size, preorder.end());
        vector<int> in2(inorder.begin() + 1 + left_size, inorder.end());
        TreeNode* left = buildTree(pre1, in1);
        TreeNode* right = buildTree(pre2, in2);
        return new TreeNode(preorder[0], left, right);
    }
};
```

#### 114.二叉树展开为链表

```c++
class Solution {
    TreeNode* head;

public:
    void flatten(TreeNode* root) {
        // 处理入参空指针情况
        if (root == nullptr) {
            return;
        }
        // 遍历右子树，左子树
        flatten(root->right);
        flatten(root->left);
        // 使用头插法
        root->left = nullptr;
        root->right = head;
        head = root;
    }
};
```

#### 236.二叉树的最近公共祖先

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 若当前节点为空或等于p/q，直接返回当前节点
        if (!root || root == p || root == q) {
            return root;
        }
        // 递归搜索左右子树
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        // 左右子树均找到目标节点,返回当前节点
        if (left && right) {
            return root;
        }
        // 看左子树是否为空，为空则递归右子树
        return left ? left : right;
    }
};
```

---

## 回溯

### Medium

#### 17.电话号码的字母组合

```c++
class Solution {
    // 构建映射表
    const string MAPPING[10] = {"",    "",    "abc",  "def", "ghi",
                                "jkl", "mno", "pqrs", "tuv", "wxyz"};

public:
    vector<string> letterCombinations(string digits) {
        // 获取字符串长度
        int n = digits.size();
        // 处理空字符串的情况
        if (n == 0) {
            return {};
        }
        vector<string> ans;
        string path(n, 0);
        auto dfs = [&](this auto&& dfs, int i) -> void {
            // 处理完所有数字添加结果
            if (i == n) {
                ans.emplace_back(path);
                return;
            }
            // 遍历数字对应的字母
            for (auto& c : MAPPING[digits[i] - '0']) {
                path[i] = c;
                dfs(i + 1);
            }
        };
        // 开始深度优先搜索
        dfs(0);
        return ans;
    }
};
```

#### 46.全排列

```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> ans;
        vector<int> path(n);
        vector<int> on_path(n);
        auto dfs = [&](this auto&& dfs, int i) {
            // 已生成完整排列则保存
            if (i == n) {
                ans.emplace_back(path);
                return;
            }
            // 遍历所有数字
            for (int j = 0; j < n; j++) {
                // 若元素未使用
                if (!on_path[j]) {
                    // 选择数字
                    path[i] = nums[j];
                    on_path[j] = true;
                    // 填充下一个位置
                    dfs(i + 1);
                    // 回溯
                    on_path[j] = false;
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```

#### 78.子集

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> ans;
        vector<int> path;
        auto dfs = [&](this auto&& dfs, int i) -> void {
            // 递归终止,将当前路径加入结果集
            if (i == n) {
                ans.emplace_back(path);
                return;
            }
            // 不选，直接递归下一层
            dfs(i + 1);
            // 选，选择当前数字
            path.push_back(nums[i]);
            dfs(i + 1);
            path.pop_back();
        };
        dfs(0);
        return ans;
    }
};
```

#### 39.组合总和

```c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> path;
        function<void(int, int)> dfs = [&](int i, int left) {
            if (left == 0) {
                // 找到一个合法组合
                ans.push_back(path);
                return;
            }
            if (i == candidates.size() || left < 0) {
                return;
            }
            // 不选
            dfs(i + 1, left);
            // 选
            path.push_back(candidates[i]);
            dfs(i, left - candidates[i]);
            path.pop_back();
        };
        dfs(0, target);
        return ans;
    }
};
```

### Hard

#### 51.N皇后

```c++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;
        vector board(n, string(n, '.'));
        vector<uint8_t> col(n, false);
        vector<uint8_t> diag1(n * 2 - 1, false);
        vector<uint8_t> diag2(n * 2 - 1, false);
        auto dfs = [&](this auto&& dfs, int r) {
            // 所有行都已放置皇后
            if (r == n) {
                ans.push_back(board);
                return;
            }
            // 放置皇后
            for (int c = 0; c < n; c++) {
                // 计算两条对角线的索引
                int diag1_idx = r + c;
                int diag2_idx = r - c + n - 1;
                // 检查当前位置是否安全
                if (!col[c] && !diag1[diag1_idx] && !diag2[diag2_idx]) {
                    // 放置皇后,标记并回溯
                    board[r][c] = 'Q';
                    col[c] = diag1[diag1_idx] = diag2[diag2_idx] = true;
                    dfs(r + 1);
                    col[c] = diag1[diag1_idx] = diag2[diag2_idx] = false;
                    board[r][c] = '.';
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```

---

## 图论

### Medium

#### 200.岛屿数量

```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int ans = 0;
        int m = grid.size();
        int n = grid[0].size();
        // 标记陆地的深度优先搜索
        auto dfs = [&](this auto&& dfs, int i, int j) -> void {
            // 边界检查
            if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') {
                return;
            }
            // 插旗避免来回横跳，递归搜索
            grid[i][j] = '2';
            dfs(i, j - 1);
            dfs(i, j + 1);
            dfs(i - 1, j);
            dfs(i + 1, j);
        };
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 发现新岛屿则标记所有陆地
                if (grid[i][j] == '1') {
                    dfs(i, j);
                    ans++;
                }
            }
        }
        return ans;
    }
};
```

#### 207.课程表

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 构建邻接表，表示每个课程的前置课程
        vector<vector<int>> g(numCourses);
        for (auto& p : prerequisites) {
            g[p[1]].push_back(p[0]);
        }
        vector<int> colors(numCourses, 0);
        // 定义一个递归的 DFS 函数，返回 true 表示找到了环
        auto dfs = [&](this auto&& dfs, int i) -> bool {
            colors[i] = 1; // 标记 i 正在访问中
            for (int y : g[i]) {
                if (colors[y] == 1 || (colors[y] == 0 && dfs(y))) {
                    return true;
                }
            }
            colors[i] = 2;
            return false;
        };
        // 遍历所有课程，检查是否存在环
        for (int i = 0; i < numCourses; i++) {
            if (colors[i] == 0 && dfs(i)) {
                return false;
            }
        }
        return true;
    }
};
```

---

## 栈

### Easy

#### 20.有效的括号

```c++
class Solution {
public:
    bool isValid(string s) {
        // 字符串长度为奇数直接false
        if (s.size() % 2) {
            return false;
        }
        // 遍历字符串
        stack<char> st;
        for (auto cur : s) {
            if (cur == '(') {
                st.push(')');
            } else if (cur == '[') {
                st.push(']');
            } else if (cur == '{') {
                st.push('}');
            } else {
                // 没有左括号，或者左括号类型不对,返回false
                if (st.empty() || st.top() != cur) {
                    return false;
                }
                // 出栈
                st.pop();
            }
        }
        return st.empty();
    }
};
```

#### 155.最小栈

```c++
class MinStack {
    stack<pair<int, int>> st;

public:
    // 使用栈存储元素
    MinStack() { st.emplace(0, INT_MAX); }
    // 弹栈
    void push(int val) { st.emplace(val, min(getMin(), val)); }
    // 入栈
    void pop() { st.pop(); }
    // 弹出栈顶
    int top() { return st.top().first; }
    // 使用栈存储元素
    int getMin() { return st.top().second; }
};
```

### Medium

#### 739.每日温度

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // 主要是用单调栈的解法解题
        int n = temperatures.size();
        vector<int> ans(n, 0);
        stack<int> st;
        for (int i = n - 1; i >= 0; i--) {
            int currentTemperature = temperatures[i];
            // 弹出所有温度 <= 当前温度的栈顶元素
            while (!st.empty() &&
                   currentTemperature >= temperatures[st.top()]) {
                st.pop();
            }
            // 搜索栈顶元素
            if (!st.empty()) {
                ans[i] = st.top() - i;
            }
            st.push(i);
        }
        return ans;
    }
};
```

#### 84.柱状图中最大的矩形

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        heights.push_back(-1);
        stack<int> st;
        st.push(-1);
        int ans = 0;
        // 遍历基地
        for (int right = 0; right < heights.size(); right++) {
            while (st.size() > 1 && heights[right] <= heights[st.top()]) {
                // 计算矩形面积
                int i = st.top();
                st.pop();
                int left = st.top();
                ans = max(ans, heights[i] * (right - left - 1));
            }
            st.push(right);
        }
        return ans;
    }
};
```

---

## 字符串

### Easy

#### 14.最长公共前缀

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        // 处理字符串为空的情况
        if (strs.empty()) {
            return " ";
        }
        // 以第一个字符串为基准字符串遍历即可
        string& baseStr = strs[0];
        for (int j = 0; j < baseStr.size(); j++) {
            for (string& s : strs) {
                if (j == s.size() || s[j] != baseStr[j]) {
                    return baseStr.substr(0, j);
                }
            }
        }
        return baseStr;
    }
};
```

### Medium

#### 415.字符串相加

```c++
class Solution {
public:
    string addStrings(string num1, string num2) {
        // 获取字符串长度并初始化指针
        int m = num1.size();
        int n = num2.size();
        int i = m - 1;
        int j = n - 1;
        int add = 0;
        string ans;
        // 预分配空间
        ans.reserve(max(m, n) + 1);
        while (i >= 0 || j >= 0 || add) {
            int x = (i >= 0) ? num1[i--] - '0' : 0;
            int y = (j >= 0) ? num2[j--] - '0' : 0;
            // 计算当前位总和
            int sum = x + y + add;
            ans.push_back('0' + sum % 10);
            add = sum / 10;
        }
        // 将逆序结果反转后返回
        return string(ans.rbegin(), ans.rend());
    }
};
```

---

## 贪心

### Easy

#### 121.买卖股票的最佳时机

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int ans = 0;
        int minPrice = prices[0];
        for (int i = 1; i < n; i++) {
            auto cur = prices[i];
            ans = max(ans, cur - minPrice);
            minPrice = min(minPrice, cur);
        }
        return ans;
    }
};
```

### Medium

#### 55.跳跃游戏

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int maxDistance = 0;
        // 遍历数组，维护最右可达位置，某次达不到就返回false
        for (int i = 0; i < nums.size(); i++) {
            if (i > maxDistance) {
                return false;
            }
            maxDistance = max(maxDistance, i + nums[i]);
        }
        return true;
    }
};
```

#### 45.跳跃游戏II

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int ans = 0;
        int current_right = 0;
        int next_right = 0;
        // 寻找最远可以跳到的地方
        for (int i = 0; i < nums.size() - 1; i++) {
            next_right = max(next_right, i + nums[i]);
            // 建桥寻找方案
            if (i == current_right) {
                current_right = next_right;
                ans++;
            }
        }
        // 输出结果
        return ans;
    }
};
```

---

## 矩阵

### Medium

#### 48.旋转图像

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // 转置
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < i; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        // 后翻转
        for (auto& row : matrix) {
            ranges::reverse(row);
        }
    }
};
```

#### 54.螺旋矩阵

```c++
class Solution {
    static constexpr int DIRS[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int> ans(m * n);
        int i = 0;
        int j = 0;
        int di = 0;
        for (int k = 0; k < m * n; k++) {
            // 标记当前位置已访问
            ans[k] = matrix[i][j];
            // 计算按当前方向的下一个位置
            matrix[i][j] = INT_MAX;
            int x = i + DIRS[di][0];
            int y = j + DIRS[di][1];
            // 检查是否需要改变方向（越界或已访问）
            if (x < 0 || y < 0 || x >= m || y >= n || matrix[x][y] == INT_MAX) {
                di = (di + 1) % 4;
            }
            // 移动到下一个位置
            i += DIRS[di][0];
            j += DIRS[di][1];
        }
        return ans;
    }
};
```

#### 240.搜索二维矩阵II

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m=matrix.size();
        int n=matrix[0].size();
        int i=0;
        int j=n-1;
        while(i<m&&j>=0){
            // 如果右上角元素为target直接输出
            if(matrix[i][j]==target){
                return true;
            }else if(matrix[i][j]<target){
                // 本行所有数小于target，搜下一行
                i++;
            }else if(matrix[i][j]>target){
                // 本列所有数大于target，搜下一列
                j--;
            }
        }
        return false;
    }
};
```

---

## 排序

### Medium

#### 56.合并区间

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // 按区间起始点排序
        ranges::sort(intervals);
        vector<vector<int>> ans;
        for (auto& current : intervals) {
            // 当前区间与结果中最后一个区间重叠
            if (!ans.empty() && current[0] <= ans.back()[1]) {
                ans.back()[1] = max(ans.back()[1], current[1]);
            } else {
                // 当前区间无重叠
                ans.emplace_back(current);
            }
        }
        return ans;
    }
};
```

#### 215.数组中的第K个最大元素

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        // 排序取倒数第K大的元素即可
        ranges::sort(nums);
        int ret = nums[n - k];
        return ret;
    }
};
```

---

## 位运算

### Easy

#### 136.只出现一次的数字

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        // 遍历数组中的每个元素,只出现一次的数字会保留
        for (auto num : nums) {
            ans ^= num;
        }
        return ans;
    }
};
```

### Medium

#### 43.字符串相乘

```c++
class Solution {
public:
    string multiply(string num1, string num2) {
        // 边界处理
        if (num1 == "0" || num2 == "0") {
            return "0";
        }
        int m = num1.size();
        int n = num2.size();
        vector<int> ansArr(m + n, 0);
        // 逐位相乘并累加
        for (int i = m - 1; i >= 0; i--) {
            int x = num1[i] - '0';
            if (x == 0) {
                continue;
            }
            for (int j = n - 1; j >= 0; j--) {
                int y = num2[j] - '0';
                if (y == 0) {
                    continue;
                }
                ansArr[i + j + 1] += x * y;
            }
        }
        // 统一进位
        int carry = 0;
        for (int i = m + n - 1; i >= 0; i--) {
            int sum = ansArr[i] + carry;
            carry = sum / 10;
            ansArr[i] = sum % 10;
        }
        // 转换为字符串
        string ans;
        int start = 0;
        if (ansArr[0] == 0) {
            start = 1;
        }
        for (int i = start; i < m + n; i++) {
            ans += (ansArr[i] + '0');
        }
        return ans;
    }
};
```

---

## 堆

### Hard

#### 295.数据流的中位数

```c++
class MedianFinder {
    // 最大堆，最小堆
    priority_queue<int> left;
    priority_queue<int, vector<int>, greater<>> right;

public:
    // 添加数字并动态平衡最大最小两个堆
    void addNum(int num) {
        if (left.size() == right.size()) {
            // 两堆大小相等时：添加后需使left堆大小+1
            right.push(num);
            left.push(right.top());
            right.pop();
        } else {
            left.push(num);
            right.push(left.top());
            left.pop();
        }
    }
    // 查找当前中位数
    double findMedian() {
        if (left.size() > right.size()) {
            return left.top();
        }
        return (left.top() + right.top()) / 2.0;
    }
};
```

---

## 前缀和

### Medium

#### 238.除自身以外数组的乘积

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        // 计算前缀乘积
        vector<int> prefix(n, 1);
        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] * nums[i - 1];
        }
        // 计算后缀乘积
        vector<int> suffix(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            suffix[i] = suffix[i + 1] * nums[i + 1];
        }
        // 计算前后缀乘积作为答案输出
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            ans[i] = prefix[i] * suffix[i];
        }
        return ans;
    }
};
```

---

## 字典树

### Medium

#### 208.实现Trie(前缀树)

```c++
struct Node {
    Node* son[26]{};
    bool end = false;
};
class Trie {
    Node* root = new Node();
    int find(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) {
                return 0;
            }
            cur = cur->son[c];
        }
        // 走过同样的路（2=完全匹配，1=前缀匹配）
        return cur->end ? 2 : 1;
    }

public:
    void insert(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) { // 无路可走？
                cur->son[c] = new Node(); // new 出来！
            }
            cur = cur->son[c];
        }
        cur->end = true;
    }
    bool search(string word) { return find(word) == 2; }
    bool startsWith(string prefix) { return find(prefix) != 0; }
};
```

---

## BFS

### Medium

#### 102.二叉树的层序遍历

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        // 若根节点为空，直接返回空二维数组
        if (root == nullptr) {
            return {};
        }
        vector<vector<int>> ans;
        queue<TreeNode*> q;
        q.push(root);
        // 循环处理直到队列为空
        while (!q.empty()) {
            vector<int> vals;
            // 保存当前层节点数
            for (int n = q.size(); n > 0; n--) {
                auto node = q.front();
                q.pop();
                vals.push_back(node->val);
                // 将非空子节点加入队列
                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
            // 存入结果
            ans.emplace_back(vals);
        }
        return ans;
    }
};
```

#### 513.找树左下角的值

```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        TreeNode* node;
        queue<TreeNode*> q;
        q.push(root);
        // 遍历所有节点
        while (!q.empty()) {
            node = q.front();
            q.pop();
            // 先右后左入队
            if (node->right) {
                q.push(node->right);
            }
            if (node->left) {
                q.push(node->left);
            }
        }
        // 返回目标节点的值
        return node->val;
    }
};
```
